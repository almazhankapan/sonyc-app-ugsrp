{"ast":null,"code":"function _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction Alignment(params) {\n  var viewSize = params.viewSize,\n      align = params.align;\n  var predefined = {\n    start: start,\n    center: center,\n    end: end\n  };\n\n  function start() {\n    return 0;\n  }\n\n  function center(n) {\n    return (viewSize - n) / 2;\n  }\n\n  function end(n) {\n    return viewSize - n;\n  }\n\n  function percent() {\n    return viewSize * Number(align);\n  }\n\n  function measure(n) {\n    if (typeof align === 'number') return percent();\n    return predefined[align](n);\n  }\n\n  var self = {\n    measure: measure\n  };\n  return self;\n}\n\nfunction Animation(callback) {\n  var animationFrame = 0;\n\n  function ifAnimating(active, cb) {\n    return function () {\n      if (active === !!animationFrame) cb();\n    };\n  }\n\n  function start() {\n    animationFrame = window.requestAnimationFrame(callback);\n  }\n\n  function stop() {\n    window.cancelAnimationFrame(animationFrame);\n    animationFrame = 0;\n  }\n\n  var self = {\n    proceed: ifAnimating(true, start),\n    start: ifAnimating(false, start),\n    stop: ifAnimating(true, stop)\n  };\n  return self;\n}\n\nfunction Axis(axis) {\n  var scroll = axis === 'y' ? 'y' : 'x';\n  var cross = axis === 'y' ? 'x' : 'y';\n\n  function measure(node) {\n    var _a = node.getBoundingClientRect(),\n        width = _a.width,\n        height = _a.height;\n\n    return scroll === 'x' ? width : height;\n  }\n\n  var self = {\n    cross: cross,\n    measure: measure,\n    scroll: scroll\n  };\n  return self;\n}\n\nfunction Counter(params) {\n  var start = params.start,\n      limit = params.limit,\n      loop = params.loop;\n  var min = limit.min,\n      max = limit.max;\n  var type = loop ? 'loop' : 'constrain';\n  var withinLimit = limit[type];\n  var counter = withinLimit(start);\n\n  function get() {\n    return counter;\n  }\n\n  function set(n) {\n    counter = withinLimit(n);\n    return self;\n  }\n\n  function add(n) {\n    if (n !== 0) {\n      var sign = n / Math.abs(n);\n      set(get() + sign);\n      return add(n + sign * -1);\n    }\n\n    return self;\n  }\n\n  function clone() {\n    return Counter({\n      start: get(),\n      limit: limit,\n      loop: loop\n    });\n  }\n\n  var self = {\n    add: add,\n    clone: clone,\n    get: get,\n    max: max,\n    min: min,\n    set: set\n  };\n  return self;\n}\n\nfunction Vector1D(value) {\n  var vector = value;\n\n  function get() {\n    return vector;\n  }\n\n  function set(n) {\n    vector = readNumber(n);\n    return self;\n  }\n\n  function add(n) {\n    vector += readNumber(n);\n    return self;\n  }\n\n  function subtract(n) {\n    vector -= readNumber(n);\n    return self;\n  }\n\n  function multiply(n) {\n    vector *= n;\n    return self;\n  }\n\n  function divide(n) {\n    vector /= n;\n    return self;\n  }\n\n  function normalize() {\n    if (vector !== 0) divide(vector);\n    return self;\n  }\n\n  function readNumber(n) {\n    return typeof n === 'number' ? n : n.get();\n  }\n\n  var self = {\n    add: add,\n    divide: divide,\n    get: get,\n    multiply: multiply,\n    normalize: normalize,\n    set: set,\n    subtract: subtract\n  };\n  return self;\n}\n\nfunction Direction(value) {\n  var direction = Vector1D(normalize(value));\n  var get = direction.get;\n\n  function normalize(n) {\n    return n === 0 ? 0 : n / Math.abs(n);\n  }\n\n  function set(v) {\n    var d = normalize(v.get());\n    if (d !== 0) direction.set(d);\n    return self;\n  }\n\n  var self = {\n    get: get,\n    set: set\n  };\n  return self;\n}\n\nfunction EventStore() {\n  var listeners = [];\n\n  function add(node, type, handler, options) {\n    if (options === void 0) {\n      options = false;\n    }\n\n    node.addEventListener(type, handler, options);\n    listeners.push(function () {\n      return node.removeEventListener(type, handler, options);\n    });\n    return self;\n  }\n\n  function removeAll() {\n    listeners = listeners.filter(function (remove) {\n      return remove();\n    });\n    return self;\n  }\n\n  var self = {\n    add: add,\n    removeAll: removeAll\n  };\n  return self;\n}\n\nfunction Limit(params) {\n  var min = params.min,\n      max = params.max;\n  var loopLimits = {\n    min: max,\n    max: min\n  };\n  var constrainLimits = {\n    min: min,\n    max: max\n  };\n  var length = Math.abs(min - max);\n\n  function reachedMin(n) {\n    return n < min;\n  }\n\n  function reachedMax(n) {\n    return n > max;\n  }\n\n  function reachedAny(n) {\n    return reachedMin(n) || reachedMax(n);\n  }\n\n  function reachedWhich(n) {\n    if (reachedMin(n)) return 'min';\n    if (reachedMax(n)) return 'max';\n    return '';\n  }\n\n  function removeOffset(n) {\n    if (min === max) return n;\n\n    while (reachedMin(n)) {\n      n += length;\n    }\n\n    while (reachedMax(n)) {\n      n -= length;\n    }\n\n    return n;\n  }\n\n  function loop(n) {\n    var which = reachedWhich(n);\n    return which ? loopLimits[which] : n;\n  }\n\n  function constrain(n) {\n    var which = reachedWhich(n);\n    return which ? constrainLimits[which] : n;\n  }\n\n  var self = {\n    constrain: constrain,\n    length: length,\n    loop: loop,\n    max: max,\n    min: min,\n    reachedAny: reachedAny,\n    reachedMax: reachedMax,\n    reachedMin: reachedMin,\n    removeOffset: removeOffset\n  };\n  return self;\n}\n\nfunction DragHandler(params) {\n  var target = params.target,\n      scrollBody = params.scrollBody,\n      dragFree = params.dragFree,\n      animation = params.animation,\n      axis = params.axis;\n  var element = params.element,\n      dragTracker = params.dragTracker,\n      location = params.location,\n      events = params.events,\n      limit = params.limit;\n  var scrollAxis = axis.scroll,\n      crossAxis = axis.cross;\n  var focusNodes = ['INPUT', 'SELECT', 'TEXTAREA'];\n  var startScroll = Vector1D(0);\n  var startCross = Vector1D(0);\n  var dragStartPoint = Vector1D(0);\n  var activationEvents = EventStore();\n  var interactionEvents = EventStore();\n  var removeActivationEvents = activationEvents.removeAll;\n  var removeInteractionEvents = interactionEvents.removeAll;\n  var snapForceBoost = {\n    mouse: 2.5,\n    touch: 3.5\n  };\n  var freeForceBoost = {\n    mouse: 5,\n    touch: 7\n  };\n  var baseSpeed = dragFree ? 5 : 12;\n  var dragThreshold = 4;\n  var edgeLimit = Limit({\n    min: limit.min - 70,\n    max: limit.max + 70\n  });\n  var pointerIsDown = false;\n  var preventScroll = false;\n  var preventClick = false;\n  var isMouse = false;\n\n  function addActivationEvents() {\n    var node = element;\n    activationEvents.add(node, 'touchmove', function () {\n      return undefined;\n    }).add(node, 'touchend', function () {\n      return undefined;\n    }).add(node, 'touchstart', down).add(node, 'mousedown', down).add(node, 'touchcancel', up).add(node, 'contextmenu', up).add(node, 'click', click);\n  }\n\n  function addInteractionEvents() {\n    var node = !isMouse ? element : document;\n    interactionEvents.add(node, 'touchmove', move).add(node, 'touchend', up).add(node, 'mousemove', move).add(node, 'mouseup', up);\n  }\n\n  function isFocusNode(node) {\n    var name = node.nodeName || '';\n    return focusNodes.indexOf(name) > -1;\n  }\n\n  function forceBoost() {\n    var boost = dragFree ? freeForceBoost : snapForceBoost;\n    var type = isMouse ? 'mouse' : 'touch';\n    return boost[type];\n  }\n\n  function speedFactor(forceB, forceA) {\n    var diff = delta(Math.abs(forceB), Math.abs(forceA));\n    if (Math.abs(forceB) <= Math.abs(forceA)) return 0;\n    if (forceB === 0 || forceA === 0) return 0;\n    return Math.abs(diff / forceB);\n  }\n\n  function allowedForce(force) {\n    var scrollTarget = params.scrollTarget,\n        index = params.index;\n    var currentLocation = scrollTarget.byDistance(0, false);\n    var targetChanged = currentLocation.index !== index.get();\n    var seekNext = !targetChanged && Math.abs(force) > dragThreshold;\n    var destination = force + location.get();\n\n    if (seekNext && !dragFree && !limit.reachedAny(destination)) {\n      var next = index.clone().add(Direction(force).get() * -1);\n      return scrollTarget.byIndex(next.get(), 0).distance;\n    }\n\n    if (!params.loop && edgeLimit.reachedAny(destination)) {\n      var edge = edgeLimit.reachedMax(destination) ? 'max' : 'min';\n      return edgeLimit[edge] - target.get();\n    }\n\n    return scrollTarget.byDistance(force, !dragFree).distance;\n  }\n\n  function down(evt) {\n    isMouse = evt.type === 'mousedown';\n    if (isMouse && evt.button !== 0) return;\n    var isMoving = delta(target.get(), location.get()) >= 2;\n    var clearPreventClick = isMouse || !isMoving;\n    var isNotFocusNode = !isFocusNode(evt.target);\n    var preventDefault = isMoving || isMouse && isNotFocusNode;\n    pointerIsDown = true;\n    dragTracker.pointerDown(evt);\n    dragStartPoint.set(target);\n    target.set(location);\n    scrollBody.useDefaultMass().useSpeed(80);\n    addInteractionEvents();\n    startScroll.set(dragTracker.readPoint(evt, scrollAxis));\n    startCross.set(dragTracker.readPoint(evt, crossAxis));\n    events.emit('pointerDown');\n    if (clearPreventClick) preventClick = false;\n    if (preventDefault) evt.preventDefault();\n  }\n\n  function move(evt) {\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up();\n      var moveScroll = dragTracker.readPoint(evt, scrollAxis).get();\n      var moveCross = dragTracker.readPoint(evt, crossAxis).get();\n      var diffScroll = delta(moveScroll, startScroll.get());\n      var diffCross = delta(moveCross, startCross.get());\n      preventScroll = diffScroll > diffCross;\n      if (!preventScroll && !preventClick) return up();\n    }\n\n    var diff = dragTracker.pointerMove(evt);\n    var reachedLimit = limit.reachedAny(location.get());\n    var resist = !params.loop && reachedLimit ? 2 : 1;\n    if (!preventClick && diff) preventClick = true;\n    animation.start();\n    target.add(diff / resist);\n    evt.preventDefault();\n  }\n\n  function up() {\n    var scrollTo = params.scrollTo;\n    var rawForce = dragTracker.pointerUp() * forceBoost();\n    var force = allowedForce(rawForce);\n    var factor = speedFactor(rawForce, force);\n    var isMoving = delta(target.get(), dragStartPoint.get()) >= 0.5;\n    if (isMoving && !isMouse) preventClick = true;\n    preventScroll = false;\n    pointerIsDown = false;\n    interactionEvents.removeAll();\n    scrollBody.useSpeed(baseSpeed + baseSpeed * factor);\n    scrollTo.distance(force, !dragFree);\n    isMouse = false;\n    events.emit('pointerUp');\n  }\n\n  function delta(pointB, pointA) {\n    return Math.abs(pointB - pointA);\n  }\n\n  function click(evt) {\n    if (preventClick) evt.preventDefault();\n  }\n\n  function clickAllowed() {\n    return !preventClick;\n  }\n\n  function pointerDown() {\n    return pointerIsDown;\n  }\n\n  var self = {\n    addActivationEvents: addActivationEvents,\n    clickAllowed: clickAllowed,\n    pointerDown: pointerDown,\n    removeActivationEvents: removeActivationEvents,\n    removeInteractionEvents: removeInteractionEvents\n  };\n  return self;\n}\n\nfunction DragTracker(params) {\n  var axis = params.axis,\n      pxToPercent = params.pxToPercent;\n  var scrollAxis = axis.scroll;\n  var coords = {\n    x: 'clientX',\n    y: 'clientY'\n  };\n  var startDrag = Vector1D(0);\n  var diffDrag = Vector1D(0);\n  var lastDrag = Vector1D(0);\n  var pointValue = Vector1D(0);\n  var trackInterval = 10;\n  var trackLength = 5;\n  var trackTime = 100;\n  var trackPoints = [];\n  var lastMoveTime = new Date().getTime();\n  var isMouse = false;\n\n  function readPoint(evt, type) {\n    isMouse = !evt.touches;\n    var c = coords[type];\n    var value = isMouse ? evt[c] : evt.touches[0][c];\n    return pointValue.set(value);\n  }\n\n  function pointerDown(evt) {\n    var point = readPoint(evt, scrollAxis);\n    startDrag.set(point);\n    lastDrag.set(point);\n    return pxToPercent.measure(startDrag.get());\n  }\n\n  function pointerMove(evt) {\n    var point = readPoint(evt, scrollAxis);\n    var nowTime = new Date().getTime();\n    var diffTime = nowTime - lastMoveTime;\n\n    if (diffTime >= trackInterval) {\n      if (diffTime >= trackTime) trackPoints = [];\n      trackPoints.push(point.get());\n      lastMoveTime = nowTime;\n    }\n\n    diffDrag.set(point).subtract(lastDrag);\n    lastDrag.set(point);\n    return pxToPercent.measure(diffDrag.get());\n  }\n\n  function pointerUp() {\n    var nowTime = new Date().getTime();\n    var diffTime = nowTime - lastMoveTime;\n    var currentPoint = lastDrag.get();\n    var force = trackPoints.slice(-trackLength).map(function (trackPoint) {\n      return currentPoint - trackPoint;\n    }).sort(function (p1, p2) {\n      return Math.abs(p1) < Math.abs(p2) ? 1 : -1;\n    })[0];\n    lastDrag.set(diffTime > trackTime || !force ? 0 : force);\n    trackPoints = [];\n    return pxToPercent.measure(lastDrag.get());\n  }\n\n  var self = {\n    pointerDown: pointerDown,\n    pointerMove: pointerMove,\n    pointerUp: pointerUp,\n    readPoint: readPoint\n  };\n  return self;\n}\n\nfunction PxToPercent(viewInPx) {\n  var totalPercent = 100;\n\n  function measure(n) {\n    return n / viewInPx * totalPercent;\n  }\n\n  var self = {\n    measure: measure,\n    totalPercent: totalPercent\n  };\n  return self;\n}\n\nfunction map(value, iStart, iStop, oStart, oStop) {\n  return oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart));\n}\n\nfunction arrayFromCollection(nodeList) {\n  return Array.prototype.slice.call(nodeList);\n}\n\nfunction debounce(callback, time) {\n  var timeout = {\n    id: 0\n  };\n  return function () {\n    window.clearTimeout(timeout.id);\n    timeout.id = window.setTimeout(callback, time) || 0;\n  };\n}\n\nfunction roundToDecimals(decimalPoints) {\n  var pow = Math.pow(10, decimalPoints);\n  return function (n) {\n    return Math.round(n * pow) / pow;\n  };\n}\n\nfunction groupArray(array, size) {\n  var groups = [];\n\n  for (var i = 0; i < array.length; i += size) {\n    groups.push(array.slice(i, i + size));\n  }\n\n  return groups;\n}\n\nfunction arrayKeys(array) {\n  return Object.keys(array).map(Number);\n}\n\nfunction removeClass(node, className) {\n  var cl = node.classList;\n  if (cl.contains(className)) cl.remove(className);\n}\n\nfunction addClass(node, className) {\n  var cl = node.classList;\n  if (!cl.contains(className)) cl.add(className);\n}\n\nfunction ScrollBody(params) {\n  var location = params.location,\n      speed = params.speed,\n      mass = params.mass;\n  var roundToTwoDecimals = roundToDecimals(2);\n  var velocity = Vector1D(0);\n  var acceleration = Vector1D(0);\n  var attraction = Vector1D(0);\n  var direction = Direction(0);\n  var state = {\n    speed: speed,\n    mass: mass\n  };\n\n  function update() {\n    velocity.add(acceleration);\n    location.add(velocity);\n    acceleration.multiply(0);\n  }\n\n  function applyForce(v) {\n    v.divide(state.mass);\n    acceleration.add(v);\n  }\n\n  function seek(v) {\n    attraction.set(v).subtract(location);\n    var magnitude = attraction.get();\n    var m = map(magnitude, 0, 100, 0, state.speed);\n    direction.set(attraction);\n    attraction.normalize().multiply(m).subtract(velocity);\n    applyForce(attraction);\n    return self;\n  }\n\n  function settle(v) {\n    var diff = v.get() - location.get();\n    var diffRounded = roundToTwoDecimals(diff);\n    var hasSettled = !diffRounded;\n    if (hasSettled) location.set(v);\n    return hasSettled;\n  }\n\n  function useSpeed(n) {\n    state.speed = n;\n    return self;\n  }\n\n  function useDefaultSpeed() {\n    useSpeed(speed);\n    return self;\n  }\n\n  function useMass(n) {\n    state.mass = n;\n    return self;\n  }\n\n  function useDefaultMass() {\n    useMass(mass);\n    return self;\n  }\n\n  var self = {\n    direction: direction,\n    location: location,\n    seek: seek,\n    settle: settle,\n    update: update,\n    useDefaultMass: useDefaultMass,\n    useDefaultSpeed: useDefaultSpeed,\n    useMass: useMass,\n    useSpeed: useSpeed\n  };\n  return self;\n}\n\nfunction ScrollBounds(params) {\n  var limit = params.limit,\n      location = params.location,\n      scrollBody = params.scrollBody,\n      animation = params.animation;\n  var min = limit.min,\n      max = limit.max,\n      reachedMin = limit.reachedMin,\n      reachedMax = limit.reachedMax;\n  var tolerance = 50;\n  var disabled = false;\n  var timeout = 0;\n\n  function shouldConstrain(v) {\n    if (disabled || timeout) return false;\n    if (reachedMin(location.get())) return v.get() !== min;\n    if (reachedMax(location.get())) return v.get() !== max;\n    return false;\n  }\n\n  function constrain(v) {\n    if (!shouldConstrain(v)) return;\n    timeout = window.setTimeout(function () {\n      var constraint = limit.constrain(v.get());\n      v.set(constraint);\n      scrollBody.useSpeed(10).useMass(3);\n      animation.start();\n      timeout = 0;\n    }, tolerance);\n  }\n\n  function toggleActive(active) {\n    disabled = !active;\n  }\n\n  var self = {\n    constrain: constrain,\n    toggleActive: toggleActive\n  };\n  return self;\n}\n\nfunction ScrollContain(params) {\n  var alignment = params.alignment,\n      contentSize = params.contentSize,\n      viewSize = params.viewSize;\n  var scrollBounds = Limit({\n    min: -contentSize + viewSize,\n    max: 0\n  });\n  var alignedWithinView = [alignment.measure(contentSize)];\n  var contentExceedsView = contentSize > viewSize;\n\n  function findDuplicates(scrollSnaps) {\n    var startSnap = scrollSnaps[0];\n    var endSnap = scrollSnaps[scrollSnaps.length - 1];\n    var min = scrollSnaps.lastIndexOf(startSnap) + 1;\n    var max = scrollSnaps.indexOf(endSnap);\n    return Limit({\n      min: min,\n      max: max\n    });\n  }\n\n  function measure(scrollSnaps, trim) {\n    var containedSnaps = scrollSnaps.map(scrollBounds.constrain);\n\n    var _a = findDuplicates(containedSnaps),\n        min = _a.min,\n        max = _a.max;\n\n    if (!contentExceedsView) return alignedWithinView;\n    if (!trim) return containedSnaps;\n    return containedSnaps.slice(min - 1, max + 1);\n  }\n\n  var self = {\n    measure: measure\n  };\n  return self;\n}\n\nfunction ScrollLimit(params) {\n  var contentSize = params.contentSize,\n      loop = params.loop;\n\n  function measure(scrollSnaps) {\n    var startSnap = scrollSnaps[0];\n    var endSnap = scrollSnaps[scrollSnaps.length - 1];\n    var min = loop ? startSnap - contentSize : endSnap;\n    var max = startSnap;\n    return Limit({\n      min: min,\n      max: max\n    });\n  }\n\n  var self = {\n    measure: measure\n  };\n  return self;\n}\n\nfunction ScrollLooper(params) {\n  var contentSize = params.contentSize,\n      location = params.location,\n      limit = params.limit,\n      pxToPercent = params.pxToPercent;\n  var min = limit.min + pxToPercent.measure(0.1);\n  var max = limit.max + pxToPercent.measure(0.1);\n\n  var _a = Limit({\n    min: min,\n    max: max\n  }),\n      reachedMin = _a.reachedMin,\n      reachedMax = _a.reachedMax;\n\n  function shouldLoop(direction) {\n    if (direction === 1) return reachedMax(location.get());\n    if (direction === -1) return reachedMin(location.get());\n    return false;\n  }\n\n  function loop(vectors, direction) {\n    if (!shouldLoop(direction)) return;\n    var loopDistance = contentSize * (direction * -1);\n    vectors.forEach(function (v) {\n      return v.add(loopDistance);\n    });\n  }\n\n  var self = {\n    loop: loop\n  };\n  return self;\n}\n\nfunction ScrollProgress(params) {\n  var _a = params.limit,\n      max = _a.max,\n      scrollLength = _a.length;\n\n  function get(n) {\n    var currentLocation = n - max;\n    return currentLocation / -scrollLength;\n  }\n\n  var self = {\n    get: get\n  };\n  return self;\n}\n\nfunction ScrollSnap(params) {\n  var snapSizes = params.snapSizes,\n      alignment = params.alignment,\n      loop = params.loop;\n  var alignments = snapSizes.map(alignment.measure);\n  var distancesBetween = distancesBetweenScrollSnaps();\n\n  function distancesBetweenScrollSnaps() {\n    var limit = Limit({\n      min: 0,\n      max: snapSizes.length - 1\n    });\n    var counter = Counter({\n      limit: limit,\n      start: 0,\n      loop: loop\n    });\n    return snapSizes.map(function (size, index) {\n      var next = counter.set(index + 1).get();\n      return size + alignments[index] - alignments[next];\n    });\n  }\n\n  function measure(index) {\n    var sizes = distancesBetween.slice(0, index);\n    return sizes.reduce(function (a, s) {\n      return a - s;\n    }, alignments[0]);\n  }\n\n  var self = {\n    measure: measure\n  };\n  return self;\n}\n\nfunction ScrollTarget(params) {\n  var loop = params.loop,\n      limit = params.limit,\n      scrollSnaps = params.scrollSnaps,\n      contentSize = params.contentSize;\n  var reachedMax = limit.reachedMax,\n      reachedAny = limit.reachedAny,\n      removeOffset = limit.removeOffset;\n\n  function minDistance(d1, d2) {\n    return Math.abs(d1) < Math.abs(d2) ? d1 : d2;\n  }\n\n  function findTargetSnap(target) {\n    var distance = removeOffset(target);\n    var ascDiffsToSnaps = scrollSnaps.map(function (scrollSnap) {\n      return scrollSnap - distance;\n    }).map(function (diffToSnap) {\n      return shortcut(diffToSnap, 0);\n    }).map(function (diff, i) {\n      return {\n        diff: diff,\n        index: i\n      };\n    }).sort(function (d1, d2) {\n      return Math.abs(d1.diff) - Math.abs(d2.diff);\n    });\n    var index = ascDiffsToSnaps[0].index;\n    return {\n      index: index,\n      distance: distance\n    };\n  }\n\n  function shortcut(target, direction) {\n    var t1 = target;\n    var t2 = target + contentSize;\n    var t3 = target - contentSize;\n    if (!loop) return t1;\n    if (!direction) return minDistance(minDistance(t1, t2), t3);\n    var shortest = minDistance(t1, direction === 1 ? t2 : t3);\n    return Math.abs(shortest) * direction;\n  }\n\n  function findTargetIndex(target, index) {\n    var reachedBound = !loop && reachedAny(target);\n    if (!reachedBound) return index;\n    var _a = params.index,\n        min = _a.min,\n        max = _a.max;\n    return reachedMax(target) ? min : max;\n  }\n\n  function byIndex(index, direction) {\n    var diffToSnap = scrollSnaps[index] - params.target.get();\n    var distance = shortcut(diffToSnap, direction);\n    return {\n      index: index,\n      distance: distance\n    };\n  }\n\n  function byDistance(distance, snap) {\n    var target = params.target.get() + distance;\n    var targetSnap = findTargetSnap(target);\n    var index = findTargetIndex(target, targetSnap.index);\n    var reachedBound = !loop && reachedAny(target);\n    if (!snap || reachedBound) return {\n      index: index,\n      distance: distance\n    };\n    var diffToSnap = scrollSnaps[index] - targetSnap.distance;\n    var snapDistance = distance + shortcut(diffToSnap, 0);\n    return {\n      index: index,\n      distance: snapDistance\n    };\n  }\n\n  var self = {\n    byDistance: byDistance,\n    byIndex: byIndex,\n    shortcut: shortcut\n  };\n  return self;\n}\n\nfunction ScrollTo(params) {\n  var indexCurrent = params.index,\n      scrollTarget = params.scrollTarget,\n      animation = params.animation;\n  var indexPrevious = params.indexPrevious,\n      events = params.events,\n      targetDistance = params.target;\n\n  function scrollTo(target) {\n    var distanceDiff = target.distance;\n    var indexDiff = target.index !== indexCurrent.get();\n\n    if (distanceDiff) {\n      animation.start();\n      targetDistance.add(distanceDiff);\n    }\n\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get());\n      indexCurrent.set(target.index);\n      events.emit('select');\n    }\n  }\n\n  function distance(n, snap) {\n    var target = scrollTarget.byDistance(n, snap);\n    scrollTo(target);\n  }\n\n  function index(n, direction) {\n    var targetIndex = indexCurrent.clone().set(n);\n    var target = scrollTarget.byIndex(targetIndex.get(), direction);\n    scrollTo(target);\n  }\n\n  var self = {\n    distance: distance,\n    index: index\n  };\n  return self;\n}\n\nfunction SlideLooper(params) {\n  var axis = params.axis,\n      containerLocation = params.location;\n  var contentSize = params.contentSize,\n      viewSize = params.viewSize,\n      slideSizes = params.slideSizes,\n      scrollSnaps = params.scrollSnaps;\n  var ascItems = arrayKeys(slideSizes);\n  var descItems = arrayKeys(slideSizes).reverse();\n  var loopPoints = startPoints().concat(endPoints());\n  var loopStyle = axis.scroll === 'x' ? 'left' : 'top';\n\n  function subtractItemSizes(indexes, from) {\n    return indexes.reduce(function (a, i) {\n      var size = slideSizes[i];\n      return a - size;\n    }, from);\n  }\n\n  function loopItemsIn(sizeOfGap, indexes) {\n    return indexes.reduce(function (a, i) {\n      var gapLeft = subtractItemSizes(a, sizeOfGap);\n      return gapLeft > 0 ? a.concat([i]) : a;\n    }, []);\n  }\n\n  function loopStart(sizeOfGap, indexes, from) {\n    return indexes.reduce(function (a, i) {\n      var gapFilled = a + slideSizes[i];\n      return gapFilled < sizeOfGap ? gapFilled : a;\n    }, from);\n  }\n\n  function loopPointFor(indexes, from, direction) {\n    var slideCount = ascItems.length - 1;\n    return subtractItemSizes(indexes.map(function (i) {\n      return (i + direction) % slideCount;\n    }), from);\n  }\n\n  function loopPointsFor(indexes, from, direction) {\n    var ascIndexes = indexes.slice().sort(function (a, b) {\n      return a - b;\n    });\n    return ascIndexes.map(function (index, loopIndex) {\n      var initial = contentSize * (!direction ? 0 : -1);\n      var offset = contentSize * (!direction ? 1 : 0);\n      var slidesInSpan = ascIndexes.slice(0, loopIndex);\n      var point = loopPointFor(slidesInSpan, from, direction);\n\n      var getTarget = function getTarget(location) {\n        return location > point ? initial : offset;\n      };\n\n      return {\n        point: point,\n        getTarget: getTarget,\n        index: index,\n        location: -1\n      };\n    });\n  }\n\n  function startPoints() {\n    var gap = scrollSnaps[0] - 1;\n    var indexes = loopItemsIn(gap, descItems);\n    var start = loopStart(gap, indexes, 0);\n    return loopPointsFor(indexes, start, 1);\n  }\n\n  function endPoints() {\n    var gap = viewSize - scrollSnaps[0] - 1;\n    var indexes = loopItemsIn(gap, ascItems);\n    var start = loopStart(contentSize, ascItems, -viewSize);\n    return loopPointsFor(indexes, -start, 0);\n  }\n\n  function canLoop() {\n    return loopPoints.every(function (_a) {\n      var index = _a.index;\n      var otherIndexes = ascItems.filter(function (i) {\n        return i !== index;\n      });\n      return subtractItemSizes(otherIndexes, viewSize) <= 0;\n    });\n  }\n\n  function loop(slides) {\n    loopPoints.forEach(function (loopPoint) {\n      var getTarget = loopPoint.getTarget,\n          location = loopPoint.location,\n          index = loopPoint.index;\n      var target = getTarget(containerLocation.get());\n\n      if (target !== location) {\n        slides[index].style[loopStyle] = target + \"%\";\n        loopPoint.location = target;\n      }\n    });\n  }\n\n  function clear(slides) {\n    loopPoints.forEach(function (_a) {\n      var index = _a.index;\n      slides[index].style[loopStyle] = '';\n    });\n  }\n\n  var self = {\n    canLoop: canLoop,\n    clear: clear,\n    loop: loop,\n    loopPoints: loopPoints\n  };\n  return self;\n}\n\nfunction SlidesInView(params) {\n  var contentSize = params.contentSize,\n      slideSizes = params.slideSizes,\n      viewSize = params.viewSize;\n  var inViewThreshold = params.inViewThreshold,\n      loop = params.loop;\n  var thresholds = slideSizes.map(function (s) {\n    return s * inViewThreshold;\n  });\n  var scrollSnaps = arrayKeys(slideSizes).map(scrollSnap);\n  var pointsToCheck = concatSlidePoints();\n\n  function scrollSnap(index) {\n    var span = slideSizes.slice(0, index);\n    return span.reduce(function (a, s) {\n      return a - s;\n    }, 0);\n  }\n\n  function concatSlidePoints() {\n    var offsets = loop ? [0, contentSize, -contentSize] : [0];\n    return offsets.map(slidePoints).reduce(function (a, b) {\n      return a.concat(b);\n    }, []);\n  }\n\n  function slidePoints(offset) {\n    return scrollSnaps.map(function (snap, index) {\n      return {\n        start: snap - slideSizes[index] + thresholds[index] + offset,\n        end: snap + viewSize - thresholds[index] + offset,\n        index: index\n      };\n    });\n  }\n\n  function check(location) {\n    return pointsToCheck.reduce(function (list, point) {\n      var index = point.index,\n          start = point.start,\n          end = point.end;\n      var inList = list.indexOf(index) !== -1;\n      var inView = start < location && end > location;\n      return !inList && inView ? list.concat([index]) : list;\n    }, []);\n  }\n\n  var self = {\n    check: check\n  };\n  return self;\n}\n\nfunction Translate(params) {\n  var axis = params.axis,\n      container = params.container;\n  var translates = {\n    x: x,\n    y: y\n  };\n  var translateAxis = translates[axis.scroll];\n  var roundToTwoDecimals = roundToDecimals(2);\n  var containerStyle = container.style;\n  var disabled = false;\n  var location = 0;\n\n  function x(n) {\n    return \"translate3d(\" + n + \"%,0px,0px)\";\n  }\n\n  function y(n) {\n    return \"translate3d(0px,\" + n + \"%,0px)\";\n  }\n\n  function to(v) {\n    if (disabled) return;\n    var target = roundToTwoDecimals(v.get());\n\n    if (location !== target) {\n      getComputedStyle(container).transform;\n      containerStyle.transform = translateAxis(target);\n      location = target;\n    }\n  }\n\n  function toggleActive(active) {\n    disabled = !active;\n  }\n\n  function clear() {\n    containerStyle.transform = '';\n    location = 0;\n  }\n\n  var self = {\n    clear: clear,\n    to: to,\n    toggleActive: toggleActive\n  };\n  return self;\n}\n\nfunction Engine(root, container, slides, options, events) {\n  // Options\n  var align = options.align,\n      scrollAxis = options.axis,\n      startIndex = options.startIndex,\n      inViewThreshold = options.inViewThreshold,\n      loop = options.loop,\n      speed = options.speed,\n      dragFree = options.dragFree,\n      slidesToScroll = options.slidesToScroll,\n      containScroll = options.containScroll; // Measurements\n\n  var axis = Axis(scrollAxis);\n  var pxToPercent = PxToPercent(axis.measure(container));\n  var viewSize = pxToPercent.totalPercent;\n  var slideSizes = slides.map(axis.measure).map(pxToPercent.measure);\n  var groupedSizes = groupArray(slideSizes, slidesToScroll);\n  var snapSizes = groupedSizes.map(function (g) {\n    return g.reduce(function (a, s) {\n      return a + s;\n    });\n  });\n  var snapIndexes = arrayKeys(snapSizes);\n  var contentSize = slideSizes.reduce(function (a, s) {\n    return a + s;\n  }, 0);\n  var alignment = Alignment({\n    align: align,\n    viewSize: viewSize\n  });\n  var scrollSnap = ScrollSnap({\n    snapSizes: snapSizes,\n    alignment: alignment,\n    loop: loop\n  });\n  var defaultSnaps = snapIndexes.map(scrollSnap.measure);\n  var contain = ScrollContain({\n    alignment: alignment,\n    contentSize: contentSize,\n    viewSize: viewSize\n  });\n  var shouldContain = !loop && containScroll !== '';\n  var trimSnaps = containScroll === 'trimSnaps';\n  var containedSnaps = contain.measure(defaultSnaps, trimSnaps);\n  var scrollSnaps = shouldContain ? containedSnaps : defaultSnaps; // Index\n\n  var indexMax = Math.max(0, scrollSnaps.length - 1);\n  var indexSpan = Limit({\n    min: 0,\n    max: indexMax\n  });\n  var index = Counter({\n    limit: indexSpan,\n    start: startIndex,\n    loop: loop\n  });\n  var indexPrevious = index.clone(); // ScrollLimit\n\n  var scrollLimit = ScrollLimit({\n    loop: loop,\n    contentSize: contentSize\n  });\n  var limit = scrollLimit.measure(scrollSnaps); // Draw\n\n  var update = function update() {\n    engine.scrollBody.seek(target).update();\n    var settled = engine.scrollBody.settle(target);\n\n    if (!dragHandler.pointerDown()) {\n      if (!loop) engine.scrollBounds.constrain(target);\n\n      if (settled) {\n        engine.animation.stop();\n        events.emit('settle');\n      }\n    }\n\n    if (loop) {\n      var direction = engine.scrollBody.direction.get();\n      engine.scrollLooper.loop(loopVectors, direction);\n      engine.slideLooper.loop(slides);\n    }\n\n    if (!settled) events.emit('scroll');\n    engine.translate.to(engine.scrollBody.location);\n    engine.animation.proceed();\n  }; // Shared\n\n\n  var animation = Animation(update);\n  var startLocation = scrollSnaps[index.get()];\n  var location = Vector1D(startLocation);\n  var target = Vector1D(startLocation);\n  var loopVectors = [location, target];\n  var scrollBody = ScrollBody({\n    location: location,\n    speed: speed,\n    mass: 1\n  });\n  var scrollTarget = ScrollTarget({\n    contentSize: contentSize,\n    index: index,\n    limit: limit,\n    loop: loop,\n    scrollSnaps: scrollSnaps,\n    target: target\n  });\n  var scrollTo = ScrollTo({\n    animation: animation,\n    events: events,\n    index: index,\n    indexPrevious: indexPrevious,\n    scrollTarget: scrollTarget,\n    target: target\n  }); // DragHandler\n\n  var dragHandler = DragHandler({\n    animation: animation,\n    axis: axis,\n    dragFree: dragFree,\n    dragTracker: DragTracker({\n      axis: axis,\n      pxToPercent: pxToPercent\n    }),\n    element: root,\n    events: events,\n    index: index,\n    limit: limit,\n    location: location,\n    loop: loop,\n    scrollBody: scrollBody,\n    scrollTo: scrollTo,\n    scrollTarget: scrollTarget,\n    target: target\n  }); // Slider\n\n  var engine = {\n    animation: animation,\n    axis: axis,\n    dragHandler: dragHandler,\n    pxToPercent: pxToPercent,\n    index: index,\n    indexPrevious: indexPrevious,\n    limit: limit,\n    location: location,\n    options: options,\n    scrollBody: scrollBody,\n    scrollBounds: ScrollBounds({\n      animation: animation,\n      limit: limit,\n      location: location,\n      scrollBody: scrollBody\n    }),\n    scrollLooper: ScrollLooper({\n      contentSize: contentSize,\n      limit: limit,\n      location: location,\n      pxToPercent: pxToPercent\n    }),\n    scrollProgress: ScrollProgress({\n      limit: limit\n    }),\n    scrollSnaps: scrollSnaps,\n    scrollTarget: scrollTarget,\n    scrollTo: scrollTo,\n    slideLooper: SlideLooper({\n      axis: axis,\n      contentSize: contentSize,\n      location: location,\n      scrollSnaps: scrollSnaps,\n      slideSizes: slideSizes,\n      viewSize: viewSize\n    }),\n    slidesInView: SlidesInView({\n      contentSize: contentSize,\n      inViewThreshold: inViewThreshold,\n      loop: loop,\n      slideSizes: slideSizes,\n      viewSize: viewSize\n    }),\n    snapIndexes: snapIndexes,\n    target: target,\n    translate: Translate({\n      axis: axis,\n      container: container\n    })\n  };\n  return engine;\n}\n\nfunction EventEmitter() {\n  var listeners = {\n    destroy: [],\n    pointerDown: [],\n    pointerUp: [],\n    init: [],\n    reInit: [],\n    resize: [],\n    scroll: [],\n    select: [],\n    settle: []\n  };\n\n  function emit(evt) {\n    listeners[evt].forEach(function (e) {\n      return e(evt);\n    });\n    return self;\n  }\n\n  function on(evt, cb) {\n    listeners[evt] = listeners[evt].concat([cb]);\n    return self;\n  }\n\n  function off(evt, cb) {\n    listeners[evt] = listeners[evt].filter(function (e) {\n      return e !== cb;\n    });\n    return self;\n  }\n\n  var self = {\n    emit: emit,\n    off: off,\n    on: on\n  };\n  return self;\n}\n\nvar defaultOptions = {\n  align: 'center',\n  axis: 'x',\n  containScroll: '',\n  containerSelector: '*',\n  dragFree: false,\n  draggable: true,\n  draggableClass: 'is-draggable',\n  draggingClass: 'is-dragging',\n  inViewThreshold: 0,\n  loop: false,\n  selectedClass: 'is-selected',\n  slidesToScroll: 1,\n  speed: 10,\n  startIndex: 0\n};\n\nfunction EmblaCarousel(sliderRoot, userOptions) {\n  if (userOptions === void 0) {\n    userOptions = {};\n  }\n\n  var events = EventEmitter();\n  var eventStore = EventStore();\n  var debouncedResize = debounce(resize, 500);\n  var reInit = reActivate;\n  var on = events.on,\n      off = events.off;\n  var engine;\n  var activated = false;\n\n  var options = _extends({}, defaultOptions);\n\n  var rootElementSize = 0;\n  var container;\n  var slides;\n  activate(userOptions);\n\n  function storeElements() {\n    if (!sliderRoot) throw new Error('Missing root node ðŸ˜¢');\n    var selector = options.containerSelector;\n    var sliderContainer = sliderRoot.querySelector(selector);\n    if (!sliderContainer) throw new Error('Missing container node ðŸ˜¢');\n    container = sliderContainer;\n    slides = arrayFromCollection(container.children);\n  }\n\n  function activate(partialOptions) {\n    if (partialOptions === void 0) {\n      partialOptions = {};\n    }\n\n    storeElements();\n    options = _extends(options, partialOptions);\n    engine = Engine(sliderRoot, container, slides, options, events);\n    var axis = engine.axis,\n        scrollBody = engine.scrollBody,\n        translate = engine.translate,\n        dragHandler = engine.dragHandler,\n        slideLooper = engine.slideLooper;\n    var loop = options.loop,\n        draggable = options.draggable,\n        draggableClass = options.draggableClass,\n        selectedClass = options.selectedClass,\n        draggingClass = options.draggingClass;\n    rootElementSize = axis.measure(sliderRoot);\n    eventStore.add(window, 'resize', debouncedResize);\n    translate.to(scrollBody.location);\n    slides.forEach(slideFocusEvent);\n    dragHandler.addActivationEvents();\n\n    if (loop) {\n      if (!slideLooper.canLoop()) return reActivate({\n        loop: false\n      });\n      slideLooper.loop(slides);\n    }\n\n    if (draggable && slides.length) {\n      if (draggableClass) {\n        addClass(sliderRoot, draggableClass);\n      }\n\n      if (draggingClass) {\n        events.on('pointerDown', toggleDraggingClass);\n        events.on('pointerUp', toggleDraggingClass);\n      }\n    } else {\n      events.on('pointerDown', dragHandler.removeInteractionEvents);\n    }\n\n    if (selectedClass) {\n      toggleSelectedClass();\n      events.on('select', toggleSelectedClass);\n      events.on('pointerUp', toggleSelectedClass);\n    }\n\n    if (!activated) {\n      setTimeout(function () {\n        return events.emit('init');\n      }, 0);\n      activated = true;\n    }\n  }\n\n  function toggleDraggingClass(evt) {\n    var draggingClass = options.draggingClass;\n    if (evt === 'pointerDown') addClass(sliderRoot, draggingClass);else removeClass(sliderRoot, draggingClass);\n  }\n\n  function toggleSelectedClass() {\n    var selectedClass = options.selectedClass;\n    var inView = slidesInView(true);\n    var notInView = slidesNotInView(true);\n    notInView.forEach(function (i) {\n      return removeClass(slides[i], selectedClass);\n    });\n    inView.forEach(function (i) {\n      return addClass(slides[i], selectedClass);\n    });\n  }\n\n  function slideFocusEvent(slide, index) {\n    var focus = function focus() {\n      var groupIndex = Math.floor(index / options.slidesToScroll);\n      var selectedGroup = index ? groupIndex : index;\n      sliderRoot.scrollLeft = 0;\n      scrollTo(selectedGroup);\n    };\n\n    eventStore.add(slide, 'focus', focus, true);\n  }\n\n  function reActivate(partialOptions) {\n    if (partialOptions === void 0) {\n      partialOptions = {};\n    }\n\n    var startIndex = selectedScrollSnap();\n\n    var newOptions = _extends({\n      startIndex: startIndex\n    }, partialOptions);\n\n    deActivate();\n    activate(newOptions);\n    events.emit('reInit');\n  }\n\n  function deActivate() {\n    engine.dragHandler.removeActivationEvents();\n    engine.dragHandler.removeInteractionEvents();\n    engine.animation.stop();\n    eventStore.removeAll();\n    engine.translate.clear();\n    engine.slideLooper.clear(slides);\n    removeClass(sliderRoot, options.draggableClass);\n    slides.forEach(function (s) {\n      return removeClass(s, options.selectedClass);\n    });\n    events.off('select', toggleSelectedClass);\n    events.off('pointerUp', toggleSelectedClass);\n    events.off('pointerDown', toggleDraggingClass);\n    events.off('pointerUp', toggleDraggingClass);\n  }\n\n  function destroy() {\n    if (!activated) return;\n    deActivate();\n    activated = false;\n    engine = {};\n    events.emit('destroy');\n  }\n\n  function resize() {\n    var newRootElementSize = engine.axis.measure(sliderRoot);\n    if (rootElementSize !== newRootElementSize) reActivate();\n    events.emit('resize');\n  }\n\n  function slidesInView(target) {\n    if (target === void 0) {\n      target = false;\n    }\n\n    var location = engine[target ? 'target' : 'location'].get();\n    var type = options.loop ? 'removeOffset' : 'constrain';\n    return engine.slidesInView.check(engine.limit[type](location));\n  }\n\n  function slidesNotInView(target) {\n    if (target === void 0) {\n      target = false;\n    }\n\n    var inView = slidesInView(target);\n    return engine.snapIndexes.filter(function (i) {\n      return inView.indexOf(i) === -1;\n    });\n  }\n\n  function scrollTo(index) {\n    engine.scrollBody.useDefaultMass().useDefaultSpeed();\n    engine.scrollTo.index(index, 0);\n  }\n\n  function scrollNext() {\n    var next = engine.index.clone().add(1);\n    engine.scrollBody.useDefaultMass().useDefaultSpeed();\n    engine.scrollTo.index(next.get(), -1);\n  }\n\n  function scrollPrev() {\n    var prev = engine.index.clone().add(-1);\n    engine.scrollBody.useDefaultMass().useDefaultSpeed();\n    engine.scrollTo.index(prev.get(), 1);\n  }\n\n  function canScrollNext() {\n    var next = engine.index.clone().add(1);\n    return next.get() !== selectedScrollSnap();\n  }\n\n  function canScrollPrev() {\n    var prev = engine.index.clone().add(-1);\n    return prev.get() !== selectedScrollSnap();\n  }\n\n  function scrollSnapList() {\n    return engine.scrollSnaps.map(engine.scrollProgress.get);\n  }\n\n  function scrollProgress() {\n    return engine.scrollProgress.get(engine.location.get());\n  }\n\n  function selectedScrollSnap() {\n    return engine.index.get();\n  }\n\n  function previousScrollSnap() {\n    return engine.indexPrevious.get();\n  }\n\n  function clickAllowed() {\n    return engine.dragHandler.clickAllowed();\n  }\n\n  function dangerouslyGetEngine() {\n    return engine;\n  }\n\n  function containerNode() {\n    return container;\n  }\n\n  function slideNodes() {\n    return slides;\n  }\n\n  var self = {\n    canScrollNext: canScrollNext,\n    canScrollPrev: canScrollPrev,\n    clickAllowed: clickAllowed,\n    containerNode: containerNode,\n    dangerouslyGetEngine: dangerouslyGetEngine,\n    destroy: destroy,\n    off: off,\n    on: on,\n    previousScrollSnap: previousScrollSnap,\n    reInit: reInit,\n    scrollNext: scrollNext,\n    scrollPrev: scrollPrev,\n    scrollProgress: scrollProgress,\n    scrollSnapList: scrollSnapList,\n    scrollTo: scrollTo,\n    selectedScrollSnap: selectedScrollSnap,\n    slideNodes: slideNodes,\n    slidesInView: slidesInView,\n    slidesNotInView: slidesNotInView\n  };\n  return self;\n}\n\nexport default EmblaCarousel;","map":{"version":3,"sources":["src/vanilla/components/alignment.ts","src/vanilla/components/animation.ts","src/vanilla/components/axis.ts","src/vanilla/components/counter.ts","src/vanilla/components/vector1d.ts","src/vanilla/components/direction.ts","src/vanilla/components/eventStore.ts","src/vanilla/components/limit.ts","src/vanilla/components/dragHandler.ts","src/vanilla/components/dragTracker.ts","src/vanilla/components/pxToPercent.ts","src/vanilla/components/utils.ts","src/vanilla/components/scrollBody.ts","src/vanilla/components/scrollBounds.ts","src/vanilla/components/scrollContain.ts","src/vanilla/components/scrollLimit.ts","src/vanilla/components/scrollLooper.ts","src/vanilla/components/scrollProgress.ts","src/vanilla/components/scrollSnap.ts","src/vanilla/components/scrollTarget.ts","src/vanilla/components/scrollTo.ts","src/vanilla/components/slideLooper.ts","src/vanilla/components/slidesInView.ts","src/vanilla/components/translate.ts","src/vanilla/components/engine.ts","src/vanilla/components/eventEmitter.ts","src/vanilla/components/options.ts","src/vanilla/index.ts"],"names":["Alignment","params","align","predefined","start","center","end","viewSize","Number","percent","self","measure","Animation","callback","animationFrame","active","cb","window","proceed","ifAnimating","stop","Axis","axis","scroll","cross","width","height","node","Counter","limit","loop","max","type","withinLimit","counter","n","sign","Math","set","get","add","clone","min","Vector1D","value","vector","readNumber","divide","multiply","normalize","subtract","Direction","direction","d","v","EventStore","listeners","removeAll","Limit","loopLimits","constrainLimits","length","reachedMin","reachedMax","which","reachedWhich","constrain","reachedAny","removeOffset","DragHandler","scrollBody","dragFree","animation","dragTracker","location","events","scrollAxis","crossAxis","focusNodes","startScroll","startCross","dragStartPoint","activationEvents","interactionEvents","removeActivationEvents","removeInteractionEvents","snapForceBoost","mouse","touch","freeForceBoost","baseSpeed","dragThreshold","edgeLimit","pointerIsDown","preventScroll","preventClick","isMouse","name","boost","diff","delta","forceB","forceA","index","currentLocation","scrollTarget","targetChanged","seekNext","destination","force","next","edge","target","evt","isMoving","clearPreventClick","isNotFocusNode","isFocusNode","preventDefault","addInteractionEvents","up","moveScroll","moveCross","diffScroll","diffCross","reachedLimit","resist","rawForce","forceBoost","allowedForce","factor","speedFactor","scrollTo","pointB","addActivationEvents","clickAllowed","pointerDown","DragTracker","pxToPercent","coords","x","y","startDrag","diffDrag","lastDrag","pointValue","trackInterval","trackLength","trackTime","trackPoints","lastMoveTime","c","point","readPoint","nowTime","diffTime","currentPoint","pointerMove","pointerUp","PxToPercent","viewInPx","totalPercent","map","iStart","iStop","oStart","oStop","arrayFromCollection","nodeList","Array","debounce","time","timeout","id","roundToDecimals","decimalPoints","pow","groupArray","array","size","groups","i","arrayKeys","Object","removeClass","className","cl","addClass","ScrollBody","speed","mass","roundToTwoDecimals","velocity","acceleration","attraction","state","magnitude","m","applyForce","diffRounded","hasSettled","useSpeed","useMass","seek","settle","update","useDefaultMass","useDefaultSpeed","ScrollBounds","tolerance","disabled","shouldConstrain","constraint","toggleActive","ScrollContain","contentSize","scrollBounds","alignedWithinView","alignment","contentExceedsView","startSnap","scrollSnaps","endSnap","containedSnaps","findDuplicates","ScrollLimit","ScrollLooper","shouldLoop","loopDistance","vectors","ScrollProgress","scrollLength","ScrollSnap","alignments","snapSizes","distancesBetween","distancesBetweenScrollSnaps","sizes","ScrollTarget","distance","ascDiffsToSnaps","d1","d2","t1","t2","t3","minDistance","shortest","reachedBound","diffToSnap","shortcut","targetSnap","findTargetSnap","findTargetIndex","snapDistance","byDistance","byIndex","ScrollTo","indexCurrent","targetDistance","distanceDiff","indexDiff","indexPrevious","targetIndex","SlideLooper","containerLocation","slideSizes","ascItems","descItems","loopPoints","startPoints","endPoints","loopStyle","a","gapLeft","subtractItemSizes","gapFilled","slideCount","ascIndexes","initial","offset","slidesInSpan","loopPointFor","getTarget","gap","indexes","loopItemsIn","loopStart","loopPointsFor","otherIndexes","loopPoint","slides","canLoop","clear","SlidesInView","thresholds","pointsToCheck","concatSlidePoints","span","offsets","snap","inList","list","inView","check","Translate","container","translates","translateAxis","containerStyle","getComputedStyle","to","Engine","root","options","startIndex","inViewThreshold","slidesToScroll","containScroll","groupedSizes","snapIndexes","scrollSnap","defaultSnaps","contain","shouldContain","trimSnaps","indexMax","indexSpan","scrollLimit","engine","settled","dragHandler","startLocation","loopVectors","element","scrollLooper","scrollProgress","slideLooper","slidesInView","translate","EventEmitter","destroy","init","reInit","resize","select","emit","off","on","defaultOptions","containerSelector","draggable","draggableClass","draggingClass","selectedClass","eventStore","debouncedResize","activated","rootElementSize","activate","selector","sliderContainer","sliderRoot","storeElements","reActivate","toggleSelectedClass","setTimeout","notInView","slidesNotInView","focus","groupIndex","selectedGroup","selectedScrollSnap","newOptions","deActivate","newRootElementSize","prev","canScrollNext","canScrollPrev","containerNode","dangerouslyGetEngine","previousScrollSnap","scrollNext","scrollPrev","scrollSnapList","slideNodes"],"mappings":"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","sourcesContent":["export type AlignmentOption = 'start' | 'center' | 'end' | number\n\ntype Params = {\n  viewSize: number\n  align: AlignmentOption\n}\n\nexport type Alignment = {\n  measure: (n: number) => number\n}\n\nexport function Alignment(params: Params): Alignment {\n  const { viewSize, align } = params\n  const predefined = { start, center, end }\n\n  function start(): number {\n    return 0\n  }\n\n  function center(n: number): number {\n    return (viewSize - n) / 2\n  }\n\n  function end(n: number): number {\n    return viewSize - n\n  }\n\n  function percent(): number {\n    return viewSize * Number(align)\n  }\n\n  function measure(n: number): number {\n    if (typeof align === 'number') return percent()\n    return predefined[align](n)\n  }\n\n  const self: Alignment = {\n    measure,\n  }\n  return self\n}\n","type Callback = () => void\n\nexport type Animation = {\n  start: () => void\n  stop: () => void\n  proceed: () => void\n}\n\nexport function Animation(callback: FrameRequestCallback): Animation {\n  let animationFrame = 0\n\n  function ifAnimating(active: boolean, cb: Callback): Callback {\n    return (): void => {\n      if (active === !!animationFrame) cb()\n    }\n  }\n\n  function start(): void {\n    animationFrame = window.requestAnimationFrame(callback)\n  }\n\n  function stop(): void {\n    window.cancelAnimationFrame(animationFrame)\n    animationFrame = 0\n  }\n\n  const self: Animation = {\n    proceed: ifAnimating(true, start),\n    start: ifAnimating(false, start),\n    stop: ifAnimating(true, stop),\n  }\n  return self\n}\n","export type AxisOption = 'x' | 'y'\n\nexport type Axis = {\n  cross: AxisOption\n  scroll: AxisOption\n  measure: (node: HTMLElement) => number\n}\n\nexport function Axis(axis: AxisOption): Axis {\n  const scroll = axis === 'y' ? 'y' : 'x'\n  const cross = axis === 'y' ? 'x' : 'y'\n\n  function measure(node: HTMLElement): number {\n    const { width, height } = node.getBoundingClientRect()\n    return scroll === 'x' ? width : height\n  }\n\n  const self: Axis = {\n    cross,\n    measure,\n    scroll,\n  }\n  return self\n}\n","import { Limit } from './limit'\n\ntype Params = {\n  start: number\n  limit: Limit\n  loop: boolean\n}\n\nexport type Counter = {\n  min: number\n  max: number\n  get: () => number\n  set: (n: number) => Counter\n  add: (n: number) => Counter\n  clone: () => Counter\n}\n\nexport function Counter(params: Params): Counter {\n  const { start, limit, loop } = params\n  const { min, max } = limit\n  const type = loop ? 'loop' : 'constrain'\n  const withinLimit = limit[type]\n  let counter = withinLimit(start)\n\n  function get(): number {\n    return counter\n  }\n\n  function set(n: number): Counter {\n    counter = withinLimit(n)\n    return self\n  }\n\n  function add(n: number): Counter {\n    if (n !== 0) {\n      const sign = n / Math.abs(n)\n      set(get() + sign)\n      return add(n + sign * -1)\n    }\n    return self\n  }\n\n  function clone(): Counter {\n    return Counter({ start: get(), limit, loop })\n  }\n\n  const self: Counter = {\n    add,\n    clone,\n    get,\n    max,\n    min,\n    set,\n  }\n  return self\n}\n","export type Vector1D = {\n  get: () => number\n  set: (v: Vector1D | number) => Vector1D\n  add: (v: Vector1D | number) => Vector1D\n  subtract: (v: Vector1D | number) => Vector1D\n  multiply: (n: number) => Vector1D\n  divide: (n: number) => Vector1D\n  normalize: () => Vector1D\n}\n\nexport function Vector1D(value: number): Vector1D {\n  let vector = value\n\n  function get(): number {\n    return vector\n  }\n\n  function set(n: Vector1D | number): Vector1D {\n    vector = readNumber(n)\n    return self\n  }\n\n  function add(n: Vector1D | number): Vector1D {\n    vector += readNumber(n)\n    return self\n  }\n\n  function subtract(n: Vector1D | number): Vector1D {\n    vector -= readNumber(n)\n    return self\n  }\n\n  function multiply(n: number): Vector1D {\n    vector *= n\n    return self\n  }\n\n  function divide(n: number): Vector1D {\n    vector /= n\n    return self\n  }\n\n  function normalize(): Vector1D {\n    if (vector !== 0) divide(vector)\n    return self\n  }\n\n  function readNumber(n: Vector1D | number): number {\n    return typeof n === 'number' ? n : n.get()\n  }\n\n  const self: Vector1D = {\n    add,\n    divide,\n    get,\n    multiply,\n    normalize,\n    set,\n    subtract,\n  }\n  return self\n}\n","import { Vector1D } from './vector1d'\n\nexport type Direction = {\n  get: () => number\n  set: (v: Vector1D) => Direction\n}\n\nexport function Direction(value: number): Direction {\n  const direction = Vector1D(normalize(value))\n  const { get } = direction\n\n  function normalize(n: number): number {\n    return n === 0 ? 0 : n / Math.abs(n)\n  }\n\n  function set(v: Vector1D): Direction {\n    const d = normalize(v.get())\n    if (d !== 0) direction.set(d)\n    return self\n  }\n\n  const self: Direction = {\n    get,\n    set,\n  }\n  return self\n}\n","type EventRemover = () => void\ntype EventHandler = EventListener | EventListenerObject | null\ntype EventOptions = boolean | AddEventListenerOptions | undefined\n\nexport type EventStore = {\n  add: (\n    node: EventTarget,\n    type: string,\n    handler: EventHandler,\n    options?: EventOptions,\n  ) => EventStore\n  removeAll: () => EventStore\n}\n\nexport function EventStore(): EventStore {\n  let listeners: EventRemover[] = []\n\n  function add(\n    node: EventTarget,\n    type: string,\n    handler: EventHandler,\n    options: EventOptions = false,\n  ): EventStore {\n    node.addEventListener(type, handler, options)\n    listeners.push(() => {\n      return node.removeEventListener(type, handler, options)\n    })\n    return self\n  }\n\n  function removeAll(): EventStore {\n    listeners = listeners.filter(remove => remove())\n    return self\n  }\n\n  const self: EventStore = {\n    add,\n    removeAll,\n  }\n  return self\n}\n","type Limits = 'min' | 'max' | ''\n\ntype Params = {\n  min: number\n  max: number\n}\n\nexport type Limit = {\n  min: number\n  max: number\n  length: number\n  loop: (n: number) => number\n  constrain: (n: number) => number\n  reachedAny: (n: number) => boolean\n  reachedMax: (n: number) => boolean\n  reachedMin: (n: number) => boolean\n  removeOffset: (n: number) => number\n}\n\nexport function Limit(params: Params): Limit {\n  const { min, max } = params\n  const loopLimits = { min: max, max: min }\n  const constrainLimits = { min, max }\n  const length = Math.abs(min - max)\n\n  function reachedMin(n: number): boolean {\n    return n < min\n  }\n\n  function reachedMax(n: number): boolean {\n    return n > max\n  }\n\n  function reachedAny(n: number): boolean {\n    return reachedMin(n) || reachedMax(n)\n  }\n\n  function reachedWhich(n: number): Limits {\n    if (reachedMin(n)) return 'min'\n    if (reachedMax(n)) return 'max'\n    return ''\n  }\n\n  function removeOffset(n: number): number {\n    if (min === max) return n\n    while (reachedMin(n)) n += length\n    while (reachedMax(n)) n -= length\n    return n\n  }\n\n  function loop(n: number): number {\n    const which = reachedWhich(n)\n    return which ? loopLimits[which] : n\n  }\n\n  function constrain(n: number): number {\n    const which = reachedWhich(n)\n    return which ? constrainLimits[which] : n\n  }\n\n  const self: Limit = {\n    constrain,\n    length,\n    loop,\n    max,\n    min,\n    reachedAny,\n    reachedMax,\n    reachedMin,\n    removeOffset,\n  }\n  return self\n}\n","import { Animation } from './animation'\nimport { Counter } from './counter'\nimport { Direction } from './direction'\nimport { DragTracker } from './dragTracker'\nimport { EventEmitter } from './eventEmitter'\nimport { Axis } from './axis'\nimport { EventStore } from './eventStore'\nimport { Limit } from './limit'\nimport { ScrollBody } from './scrollBody'\nimport { ScrollTarget } from './scrollTarget'\nimport { ScrollTo } from './scrollTo'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  axis: Axis\n  element: HTMLElement\n  target: Vector1D\n  dragFree: boolean\n  dragTracker: DragTracker\n  location: Vector1D\n  animation: Animation\n  scrollTo: ScrollTo\n  scrollBody: ScrollBody\n  scrollTarget: ScrollTarget\n  index: Counter\n  limit: Limit\n  loop: boolean\n  events: EventEmitter\n}\n\nexport type DragHandler = {\n  addActivationEvents: () => void\n  clickAllowed: () => boolean\n  pointerDown: () => boolean\n  removeActivationEvents: EventStore['removeAll']\n  removeInteractionEvents: EventStore['removeAll']\n}\n\nexport function DragHandler(params: Params): DragHandler {\n  const { target, scrollBody, dragFree, animation, axis } = params\n  const { element, dragTracker, location, events, limit } = params\n  const { scroll: scrollAxis, cross: crossAxis } = axis\n  const focusNodes = ['INPUT', 'SELECT', 'TEXTAREA']\n  const startScroll = Vector1D(0)\n  const startCross = Vector1D(0)\n  const dragStartPoint = Vector1D(0)\n  const activationEvents = EventStore()\n  const interactionEvents = EventStore()\n  const removeActivationEvents = activationEvents.removeAll\n  const removeInteractionEvents = interactionEvents.removeAll\n  const snapForceBoost = { mouse: 2.5, touch: 3.5 }\n  const freeForceBoost = { mouse: 5, touch: 7 }\n  const baseSpeed = dragFree ? 5 : 12\n  const dragThreshold = 4\n  const edgeLimit = Limit({\n    min: limit.min - 70,\n    max: limit.max + 70,\n  })\n\n  let pointerIsDown = false\n  let preventScroll = false\n  let preventClick = false\n  let isMouse = false\n\n  function addActivationEvents(): void {\n    const node = element\n    activationEvents\n      .add(node, 'touchmove', () => undefined)\n      .add(node, 'touchend', () => undefined)\n      .add(node, 'touchstart', down)\n      .add(node, 'mousedown', down)\n      .add(node, 'touchcancel', up)\n      .add(node, 'contextmenu', up)\n      .add(node, 'click', click)\n  }\n\n  function addInteractionEvents(): void {\n    const node = !isMouse ? element : document\n    interactionEvents\n      .add(node, 'touchmove', move)\n      .add(node, 'touchend', up)\n      .add(node, 'mousemove', move)\n      .add(node, 'mouseup', up)\n  }\n\n  function isFocusNode(node: Element): boolean {\n    const name = node.nodeName || ''\n    return focusNodes.indexOf(name) > -1\n  }\n\n  function forceBoost(): number {\n    const boost = dragFree ? freeForceBoost : snapForceBoost\n    const type = isMouse ? 'mouse' : 'touch'\n    return boost[type]\n  }\n\n  function speedFactor(forceB: number, forceA: number): number {\n    const diff = delta(Math.abs(forceB), Math.abs(forceA))\n    if (Math.abs(forceB) <= Math.abs(forceA)) return 0\n    if (forceB === 0 || forceA === 0) return 0\n    return Math.abs(diff / forceB)\n  }\n\n  function allowedForce(force: number): number {\n    const { scrollTarget, index } = params\n    const currentLocation = scrollTarget.byDistance(0, false)\n    const targetChanged = currentLocation.index !== index.get()\n    const seekNext = !targetChanged && Math.abs(force) > dragThreshold\n    const destination = force + location.get()\n\n    if (seekNext && !dragFree && !limit.reachedAny(destination)) {\n      const next = index.clone().add(Direction(force).get() * -1)\n      return scrollTarget.byIndex(next.get(), 0).distance\n    }\n    if (!params.loop && edgeLimit.reachedAny(destination)) {\n      const edge = edgeLimit.reachedMax(destination) ? 'max' : 'min'\n      return edgeLimit[edge] - target.get()\n    }\n    return scrollTarget.byDistance(force, !dragFree).distance\n  }\n\n  function down(evt: Event): void {\n    isMouse = evt.type === 'mousedown'\n    if (isMouse && (evt as MouseEvent).button !== 0) return\n\n    const isMoving = delta(target.get(), location.get()) >= 2\n    const clearPreventClick = isMouse || !isMoving\n    const isNotFocusNode = !isFocusNode(evt.target as Element)\n    const preventDefault = isMoving || (isMouse && isNotFocusNode)\n\n    pointerIsDown = true\n    dragTracker.pointerDown(evt)\n    dragStartPoint.set(target)\n    target.set(location)\n    scrollBody.useDefaultMass().useSpeed(80)\n    addInteractionEvents()\n    startScroll.set(dragTracker.readPoint(evt, scrollAxis))\n    startCross.set(dragTracker.readPoint(evt, crossAxis))\n    events.emit('pointerDown')\n\n    if (clearPreventClick) preventClick = false\n    if (preventDefault) evt.preventDefault()\n  }\n\n  function move(evt: Event): void {\n    if (!preventScroll && !isMouse) {\n      if (!evt.cancelable) return up()\n      const moveScroll = dragTracker.readPoint(evt, scrollAxis).get()\n      const moveCross = dragTracker.readPoint(evt, crossAxis).get()\n      const diffScroll = delta(moveScroll, startScroll.get())\n      const diffCross = delta(moveCross, startCross.get())\n      preventScroll = diffScroll > diffCross\n      if (!preventScroll && !preventClick) return up()\n    }\n    const diff = dragTracker.pointerMove(evt)\n    const reachedLimit = limit.reachedAny(location.get())\n    const resist = !params.loop && reachedLimit ? 2 : 1\n\n    if (!preventClick && diff) preventClick = true\n    animation.start()\n    target.add(diff / resist)\n    evt.preventDefault()\n  }\n\n  function up(): void {\n    const { scrollTo } = params\n    const rawForce = dragTracker.pointerUp() * forceBoost()\n    const force = allowedForce(rawForce)\n    const factor = speedFactor(rawForce, force)\n    const isMoving = delta(target.get(), dragStartPoint.get()) >= 0.5\n\n    if (isMoving && !isMouse) preventClick = true\n    preventScroll = false\n    pointerIsDown = false\n    interactionEvents.removeAll()\n    scrollBody.useSpeed(baseSpeed + baseSpeed * factor)\n    scrollTo.distance(force, !dragFree)\n    isMouse = false\n    events.emit('pointerUp')\n  }\n\n  function delta(pointB: number, pointA: number): number {\n    return Math.abs(pointB - pointA)\n  }\n\n  function click(evt: Event): void {\n    if (preventClick) evt.preventDefault()\n  }\n\n  function clickAllowed(): boolean {\n    return !preventClick\n  }\n\n  function pointerDown(): boolean {\n    return pointerIsDown\n  }\n\n  const self: DragHandler = {\n    addActivationEvents,\n    clickAllowed,\n    pointerDown,\n    removeActivationEvents,\n    removeInteractionEvents,\n  }\n  return self\n}\n","import { Axis, AxisOption } from './axis'\nimport { PxToPercent } from './pxToPercent'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  axis: Axis\n  pxToPercent: PxToPercent\n}\n\nexport type DragTracker = {\n  pointerDown: (evt: Event) => number\n  pointerMove: (evt: Event) => number\n  pointerUp: () => number\n  readPoint: (evt: any, axis: AxisOption) => Vector1D\n}\n\nexport function DragTracker(params: Params): DragTracker {\n  const { axis, pxToPercent } = params\n  const { scroll: scrollAxis } = axis\n  const coords = { x: 'clientX', y: 'clientY' }\n  const startDrag = Vector1D(0)\n  const diffDrag = Vector1D(0)\n  const lastDrag = Vector1D(0)\n  const pointValue = Vector1D(0)\n  const trackInterval = 10\n  const trackLength = 5\n  const trackTime = 100\n  let trackPoints: number[] = []\n  let lastMoveTime = new Date().getTime()\n  let isMouse = false\n\n  function readPoint(evt: any, type: AxisOption): Vector1D {\n    isMouse = !evt.touches\n    const c = coords[type]\n    const value = isMouse ? evt[c] : evt.touches[0][c]\n    return pointValue.set(value)\n  }\n\n  function pointerDown(evt: Event): number {\n    const point = readPoint(evt, scrollAxis)\n    startDrag.set(point)\n    lastDrag.set(point)\n    return pxToPercent.measure(startDrag.get())\n  }\n\n  function pointerMove(evt: Event): number {\n    const point = readPoint(evt, scrollAxis)\n    const nowTime = new Date().getTime()\n    const diffTime = nowTime - lastMoveTime\n\n    if (diffTime >= trackInterval) {\n      if (diffTime >= trackTime) trackPoints = []\n      trackPoints.push(point.get())\n      lastMoveTime = nowTime\n    }\n\n    diffDrag.set(point).subtract(lastDrag)\n    lastDrag.set(point)\n    return pxToPercent.measure(diffDrag.get())\n  }\n\n  function pointerUp(): number {\n    const nowTime = new Date().getTime()\n    const diffTime = nowTime - lastMoveTime\n    const currentPoint = lastDrag.get()\n\n    const force = trackPoints\n      .slice(-trackLength)\n      .map(trackPoint => currentPoint - trackPoint)\n      .sort((p1, p2) => (Math.abs(p1) < Math.abs(p2) ? 1 : -1))[0]\n\n    lastDrag.set(diffTime > trackTime || !force ? 0 : force)\n    trackPoints = []\n    return pxToPercent.measure(lastDrag.get())\n  }\n\n  const self: DragTracker = {\n    pointerDown,\n    pointerMove,\n    pointerUp,\n    readPoint,\n  }\n  return self\n}\n","export type PxToPercent = {\n  measure: (n: number) => number\n  totalPercent: number\n}\n\nexport function PxToPercent(viewInPx: number): PxToPercent {\n  const totalPercent = 100\n\n  function measure(n: number): number {\n    return (n / viewInPx) * totalPercent\n  }\n\n  const self: PxToPercent = {\n    measure,\n    totalPercent,\n  }\n  return self\n}\n","export function map(\n  value: number,\n  iStart: number,\n  iStop: number,\n  oStart: number,\n  oStop: number,\n): number {\n  return (\n    oStart + (oStop - oStart) * ((value - iStart) / (iStop - iStart))\n  )\n}\n\nexport function arrayFromCollection(\n  nodeList: HTMLCollection,\n): HTMLElement[] {\n  return Array.prototype.slice.call(nodeList)\n}\n\nexport function debounce(\n  callback: () => void,\n  time: number,\n): () => void {\n  const timeout = { id: 0 }\n  return (): void => {\n    window.clearTimeout(timeout.id)\n    timeout.id = window.setTimeout(callback, time) || 0\n  }\n}\n\nexport function roundToDecimals(\n  decimalPoints: number,\n): (n: number) => number {\n  const pow = Math.pow(10, decimalPoints)\n  return (n: number) => Math.round(n * pow) / pow\n}\n\nexport function groupArray<GenericType>(\n  array: GenericType[],\n  size: number,\n): GenericType[][] {\n  const groups = []\n  for (let i = 0; i < array.length; i += size) {\n    groups.push(array.slice(i, i + size))\n  }\n  return groups\n}\n\nexport function arrayKeys<GenericType>(array: GenericType): number[] {\n  return Object.keys(array).map(Number)\n}\n\nexport function removeClass(\n  node: HTMLElement,\n  className: string,\n): void {\n  const cl = node.classList\n  if (cl.contains(className)) cl.remove(className)\n}\n\nexport function addClass(node: HTMLElement, className: string): void {\n  const cl = node.classList\n  if (!cl.contains(className)) cl.add(className)\n}\n","import { Direction } from './direction'\nimport { map, roundToDecimals } from './utils'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  location: Vector1D\n  speed: number\n  mass: number\n}\n\nexport type ScrollBody = {\n  location: Vector1D\n  direction: Direction\n  update: () => void\n  seek: (v: Vector1D) => ScrollBody\n  settle: (v: Vector1D) => boolean\n  useSpeed: (n: number) => ScrollBody\n  useDefaultSpeed: () => ScrollBody\n  useMass: (n: number) => ScrollBody\n  useDefaultMass: () => ScrollBody\n}\n\nexport function ScrollBody(params: Params): ScrollBody {\n  const { location, speed, mass } = params\n  const roundToTwoDecimals = roundToDecimals(2)\n  const velocity = Vector1D(0)\n  const acceleration = Vector1D(0)\n  const attraction = Vector1D(0)\n  const direction = Direction(0)\n  const state = { speed, mass }\n\n  function update(): void {\n    velocity.add(acceleration)\n    location.add(velocity)\n    acceleration.multiply(0)\n  }\n\n  function applyForce(v: Vector1D): void {\n    v.divide(state.mass)\n    acceleration.add(v)\n  }\n\n  function seek(v: Vector1D): ScrollBody {\n    attraction.set(v).subtract(location)\n    const magnitude = attraction.get()\n    const m = map(magnitude, 0, 100, 0, state.speed)\n    direction.set(attraction)\n    attraction\n      .normalize()\n      .multiply(m)\n      .subtract(velocity)\n    applyForce(attraction)\n    return self\n  }\n\n  function settle(v: Vector1D): boolean {\n    const diff = v.get() - location.get()\n    const diffRounded = roundToTwoDecimals(diff)\n    const hasSettled = !diffRounded\n    if (hasSettled) location.set(v)\n    return hasSettled\n  }\n\n  function useSpeed(n: number): ScrollBody {\n    state.speed = n\n    return self\n  }\n\n  function useDefaultSpeed(): ScrollBody {\n    useSpeed(speed)\n    return self\n  }\n\n  function useMass(n: number): ScrollBody {\n    state.mass = n\n    return self\n  }\n\n  function useDefaultMass(): ScrollBody {\n    useMass(mass)\n    return self\n  }\n\n  const self: ScrollBody = {\n    direction,\n    location,\n    seek,\n    settle,\n    update,\n    useDefaultMass,\n    useDefaultSpeed,\n    useMass,\n    useSpeed,\n  }\n  return self\n}\n","import { Animation } from './animation'\nimport { Limit } from './limit'\nimport { ScrollBody } from './scrollBody'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  limit: Limit\n  location: Vector1D\n  scrollBody: ScrollBody\n  animation: Animation\n}\n\nexport type ScrollBounds = {\n  constrain: (v: Vector1D) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function ScrollBounds(params: Params): ScrollBounds {\n  const { limit, location, scrollBody, animation } = params\n  const { min, max, reachedMin, reachedMax } = limit\n  const tolerance = 50\n  let disabled = false\n  let timeout = 0\n\n  function shouldConstrain(v: Vector1D): boolean {\n    if (disabled || timeout) return false\n    if (reachedMin(location.get())) return v.get() !== min\n    if (reachedMax(location.get())) return v.get() !== max\n    return false\n  }\n\n  function constrain(v: Vector1D): void {\n    if (!shouldConstrain(v)) return\n\n    timeout = window.setTimeout(() => {\n      const constraint = limit.constrain(v.get())\n      v.set(constraint)\n      scrollBody.useSpeed(10).useMass(3)\n      animation.start()\n      timeout = 0\n    }, tolerance)\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  const self: ScrollBounds = {\n    constrain,\n    toggleActive,\n  }\n  return self\n}\n","import { Alignment } from './alignment'\nimport { Limit } from './limit'\n\nexport type ScrollContainOption = '' | 'trimSnaps' | 'keepSnaps'\n\ntype Params = {\n  contentSize: number\n  viewSize: number\n  alignment: Alignment\n}\n\nexport type ScrollContain = {\n  measure: (scrollSnaps: number[], trim: boolean) => number[]\n}\n\nexport function ScrollContain(params: Params): ScrollContain {\n  const { alignment, contentSize, viewSize } = params\n  const scrollBounds = Limit({ min: -contentSize + viewSize, max: 0 })\n  const alignedWithinView = [alignment.measure(contentSize)]\n  const contentExceedsView = contentSize > viewSize\n\n  function findDuplicates(scrollSnaps: number[]): Limit {\n    const startSnap = scrollSnaps[0]\n    const endSnap = scrollSnaps[scrollSnaps.length - 1]\n    const min = scrollSnaps.lastIndexOf(startSnap) + 1\n    const max = scrollSnaps.indexOf(endSnap)\n    return Limit({ min, max })\n  }\n\n  function measure(scrollSnaps: number[], trim: boolean): number[] {\n    const containedSnaps = scrollSnaps.map(scrollBounds.constrain)\n    const { min, max } = findDuplicates(containedSnaps)\n\n    if (!contentExceedsView) return alignedWithinView\n    if (!trim) return containedSnaps\n    return containedSnaps.slice(min - 1, max + 1)\n  }\n\n  const self: ScrollContain = {\n    measure,\n  }\n  return self\n}\n","import { Limit } from './limit'\n\ntype Params = {\n  contentSize: number\n  loop: boolean\n}\n\nexport type ScrollLimit = {\n  measure: (scrollSnaps: number[]) => Limit\n}\n\nexport function ScrollLimit(params: Params): ScrollLimit {\n  const { contentSize, loop } = params\n\n  function measure(scrollSnaps: number[]): Limit {\n    const startSnap = scrollSnaps[0]\n    const endSnap = scrollSnaps[scrollSnaps.length - 1]\n    const min = loop ? startSnap - contentSize : endSnap\n    const max = startSnap\n    return Limit({ min, max })\n  }\n\n  const self: ScrollLimit = {\n    measure,\n  }\n  return self\n}\n","import { Limit } from './limit'\nimport { PxToPercent } from './pxToPercent'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  contentSize: number\n  limit: Limit\n  location: Vector1D\n  pxToPercent: PxToPercent\n}\n\nexport type ScrollLooper = {\n  loop: (vectors: Vector1D[], direction: number) => void\n}\n\nexport function ScrollLooper(params: Params): ScrollLooper {\n  const { contentSize, location, limit, pxToPercent } = params\n  const min = limit.min + pxToPercent.measure(0.1)\n  const max = limit.max + pxToPercent.measure(0.1)\n  const { reachedMin, reachedMax } = Limit({ min, max })\n\n  function shouldLoop(direction: number): boolean {\n    if (direction === 1) return reachedMax(location.get())\n    if (direction === -1) return reachedMin(location.get())\n    return false\n  }\n\n  function loop(vectors: Vector1D[], direction: number): void {\n    if (!shouldLoop(direction)) return\n\n    const loopDistance = contentSize * (direction * -1)\n    vectors.forEach(v => v.add(loopDistance))\n  }\n\n  const self: ScrollLooper = {\n    loop,\n  }\n  return self\n}\n","import { Limit } from './limit'\r\n\r\ntype Params = {\r\n  limit: Limit\r\n}\r\n\r\nexport type ScrollProgress = {\r\n  get: (n: number) => number\r\n}\r\n\r\nexport function ScrollProgress(params: Params): ScrollProgress {\r\n  const { max, length: scrollLength } = params.limit\r\n\r\n  function get(n: number): number {\r\n    const currentLocation = n - max\r\n    return currentLocation / -scrollLength\r\n  }\r\n\r\n  const self: ScrollProgress = {\r\n    get,\r\n  }\r\n  return self\r\n}\r\n","import { Alignment } from './alignment'\nimport { Counter } from './counter'\nimport { Limit } from './limit'\n\ntype Params = {\n  snapSizes: number[]\n  alignment: Alignment\n  loop: boolean\n}\n\nexport type ScrollSnap = {\n  measure: (index: number) => number\n}\n\nexport function ScrollSnap(params: Params): ScrollSnap {\n  const { snapSizes, alignment, loop } = params\n  const alignments = snapSizes.map(alignment.measure)\n  const distancesBetween = distancesBetweenScrollSnaps()\n\n  function distancesBetweenScrollSnaps(): number[] {\n    const limit = Limit({ min: 0, max: snapSizes.length - 1 })\n    const counter = Counter({ limit, start: 0, loop })\n\n    return snapSizes.map((size, index) => {\n      const next = counter.set(index + 1).get()\n      return size + alignments[index] - alignments[next]\n    })\n  }\n\n  function measure(index: number): number {\n    const sizes = distancesBetween.slice(0, index)\n    return sizes.reduce((a, s) => a - s, alignments[0])\n  }\n\n  const self: ScrollSnap = {\n    measure,\n  }\n  return self\n}\n","import { Counter } from './counter'\nimport { Limit } from './limit'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  index: Counter\n  loop: boolean\n  scrollSnaps: number[]\n  contentSize: number\n  limit: Limit\n  target: Vector1D\n}\n\nexport type Target = {\n  distance: number\n  index: number\n}\n\nexport type ScrollTarget = {\n  byIndex: (target: number, direction: number) => Target\n  byDistance: (force: number, snap: boolean) => Target\n  shortcut: (target: number, direction: number) => number\n}\n\nexport function ScrollTarget(params: Params): ScrollTarget {\n  const { loop, limit, scrollSnaps, contentSize } = params\n  const { reachedMax, reachedAny, removeOffset } = limit\n\n  function minDistance(d1: number, d2: number): number {\n    return Math.abs(d1) < Math.abs(d2) ? d1 : d2\n  }\n\n  function findTargetSnap(target: number): Target {\n    const distance = removeOffset(target)\n    const ascDiffsToSnaps = scrollSnaps\n      .map(scrollSnap => scrollSnap - distance)\n      .map(diffToSnap => shortcut(diffToSnap, 0))\n      .map((diff, i) => ({ diff, index: i }))\n      .sort((d1, d2) => Math.abs(d1.diff) - Math.abs(d2.diff))\n\n    const { index } = ascDiffsToSnaps[0]\n    return { index, distance }\n  }\n\n  function shortcut(target: number, direction: number): number {\n    const t1 = target\n    const t2 = target + contentSize\n    const t3 = target - contentSize\n\n    if (!loop) return t1\n    if (!direction) return minDistance(minDistance(t1, t2), t3)\n\n    const shortest = minDistance(t1, direction === 1 ? t2 : t3)\n    return Math.abs(shortest) * direction\n  }\n\n  function findTargetIndex(target: number, index: number): number {\n    const reachedBound = !loop && reachedAny(target)\n    if (!reachedBound) return index\n\n    const { min, max } = params.index\n    return reachedMax(target) ? min : max\n  }\n\n  function byIndex(index: number, direction: number): Target {\n    const diffToSnap = scrollSnaps[index] - params.target.get()\n    const distance = shortcut(diffToSnap, direction)\n    return { index, distance }\n  }\n\n  function byDistance(distance: number, snap: boolean): Target {\n    const target = params.target.get() + distance\n    const targetSnap = findTargetSnap(target)\n    const index = findTargetIndex(target, targetSnap.index)\n    const reachedBound = !loop && reachedAny(target)\n\n    if (!snap || reachedBound) return { index, distance }\n\n    const diffToSnap = scrollSnaps[index] - targetSnap.distance\n    const snapDistance = distance + shortcut(diffToSnap, 0)\n\n    return { index, distance: snapDistance }\n  }\n\n  const self: ScrollTarget = {\n    byDistance,\n    byIndex,\n    shortcut,\n  }\n  return self\n}\n","import { Animation } from './animation'\nimport { Counter } from './counter'\nimport { EventEmitter } from './eventEmitter'\nimport { ScrollTarget, Target } from './scrollTarget'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  animation: Animation\n  target: Vector1D\n  index: Counter\n  indexPrevious: Counter\n  scrollTarget: ScrollTarget\n  events: EventEmitter\n}\n\nexport type ScrollTo = {\n  distance: (n: number, snap: boolean) => void\n  index: (n: number, direction: number) => void\n}\n\nexport function ScrollTo(params: Params): ScrollTo {\n  const { index: indexCurrent, scrollTarget, animation } = params\n  const { indexPrevious, events, target: targetDistance } = params\n\n  function scrollTo(target: Target): void {\n    const distanceDiff = target.distance\n    const indexDiff = target.index !== indexCurrent.get()\n\n    if (distanceDiff) {\n      animation.start()\n      targetDistance.add(distanceDiff)\n    }\n    if (indexDiff) {\n      indexPrevious.set(indexCurrent.get())\n      indexCurrent.set(target.index)\n      events.emit('select')\n    }\n  }\n\n  function distance(n: number, snap: boolean): void {\n    const target = scrollTarget.byDistance(n, snap)\n    scrollTo(target)\n  }\n\n  function index(n: number, direction: number): void {\n    const targetIndex = indexCurrent.clone().set(n)\n    const target = scrollTarget.byIndex(targetIndex.get(), direction)\n    scrollTo(target)\n  }\n\n  const self: ScrollTo = {\n    distance,\n    index,\n  }\n  return self\n}\n","import { Axis } from './axis'\nimport { arrayKeys } from './utils'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  axis: Axis\n  scrollSnaps: number[]\n  viewSize: number\n  location: Vector1D\n  slideSizes: number[]\n  contentSize: number\n}\n\ntype LoopPoint = {\n  point: number\n  location: number\n  index: number\n  getTarget: (location: number) => number\n}\n\nexport type SlideLooper = {\n  canLoop: () => boolean\n  clear: (slides: HTMLElement[]) => void\n  loop: (slides: HTMLElement[]) => void\n  loopPoints: LoopPoint[]\n}\n\nexport function SlideLooper(params: Params): SlideLooper {\n  const { axis, location: containerLocation } = params\n  const { contentSize, viewSize, slideSizes, scrollSnaps } = params\n  const ascItems = arrayKeys(slideSizes)\n  const descItems = arrayKeys(slideSizes).reverse()\n  const loopPoints = startPoints().concat(endPoints())\n  const loopStyle = axis.scroll === 'x' ? 'left' : 'top'\n\n  function subtractItemSizes(\n    indexes: number[],\n    from: number,\n  ): number {\n    return indexes.reduce((a: number, i) => {\n      const size = slideSizes[i]\n      return a - size\n    }, from)\n  }\n\n  function loopItemsIn(\n    sizeOfGap: number,\n    indexes: number[],\n  ): number[] {\n    return indexes.reduce((a: number[], i) => {\n      const gapLeft = subtractItemSizes(a, sizeOfGap)\n      return gapLeft > 0 ? a.concat([i]) : a\n    }, [])\n  }\n\n  function loopStart(\n    sizeOfGap: number,\n    indexes: number[],\n    from: number,\n  ): number {\n    return indexes.reduce((a: number, i) => {\n      const gapFilled = a + slideSizes[i]\n      return gapFilled < sizeOfGap ? gapFilled : a\n    }, from)\n  }\n\n  function loopPointFor(\n    indexes: number[],\n    from: number,\n    direction: 0 | 1,\n  ): number {\n    const slideCount = ascItems.length - 1\n    return subtractItemSizes(\n      indexes.map(i => (i + direction) % slideCount),\n      from,\n    )\n  }\n\n  function loopPointsFor(\n    indexes: number[],\n    from: number,\n    direction: 0 | 1,\n  ): LoopPoint[] {\n    const ascIndexes = indexes.slice().sort((a, b) => a - b)\n    return ascIndexes.map(\n      (index, loopIndex): LoopPoint => {\n        const initial = contentSize * (!direction ? 0 : -1)\n        const offset = contentSize * (!direction ? 1 : 0)\n        const slidesInSpan = ascIndexes.slice(0, loopIndex)\n        const point = loopPointFor(slidesInSpan, from, direction)\n        const getTarget = (location: number): number =>\n          location > point ? initial : offset\n        return { point, getTarget, index, location: -1 }\n      },\n    )\n  }\n\n  function startPoints(): LoopPoint[] {\n    const gap = scrollSnaps[0] - 1\n    const indexes = loopItemsIn(gap, descItems)\n    const start = loopStart(gap, indexes, 0)\n    return loopPointsFor(indexes, start, 1)\n  }\n\n  function endPoints(): LoopPoint[] {\n    const gap = viewSize - scrollSnaps[0] - 1\n    const indexes = loopItemsIn(gap, ascItems)\n    const start = loopStart(contentSize, ascItems, -viewSize)\n    return loopPointsFor(indexes, -start, 0)\n  }\n\n  function canLoop(): boolean {\n    return loopPoints.every(({ index }) => {\n      const otherIndexes = ascItems.filter(i => i !== index)\n      return subtractItemSizes(otherIndexes, viewSize) <= 0\n    })\n  }\n\n  function loop(slides: HTMLElement[]): void {\n    loopPoints.forEach(loopPoint => {\n      const { getTarget, location, index } = loopPoint\n      const target = getTarget(containerLocation.get())\n      if (target !== location) {\n        slides[index].style[loopStyle] = `${target}%`\n        loopPoint.location = target\n      }\n    })\n  }\n\n  function clear(slides: HTMLElement[]): void {\n    loopPoints.forEach(({ index }) => {\n      slides[index].style[loopStyle] = ''\n    })\n  }\n\n  const self: SlideLooper = {\n    canLoop,\n    clear,\n    loop,\n    loopPoints,\n  }\n  return self\n}\n","import { arrayKeys } from './utils'\n\ntype Params = {\n  contentSize: number\n  slideSizes: number[]\n  viewSize: number\n  loop: boolean\n  inViewThreshold: number\n}\n\ntype SlidePoint = {\n  start: number\n  end: number\n  index: number\n}\n\nexport type SlidesInView = {\n  check: (location: number) => number[]\n}\n\nexport function SlidesInView(params: Params): SlidesInView {\n  const { contentSize, slideSizes, viewSize } = params\n  const { inViewThreshold, loop } = params\n  const thresholds = slideSizes.map(s => s * inViewThreshold)\n  const scrollSnaps = arrayKeys(slideSizes).map(scrollSnap)\n  const pointsToCheck = concatSlidePoints()\n\n  function scrollSnap(index: number): number {\n    const span = slideSizes.slice(0, index)\n    return span.reduce((a, s) => a - s, 0)\n  }\n\n  function concatSlidePoints(): SlidePoint[] {\n    const offsets = loop ? [0, contentSize, -contentSize] : [0]\n    return offsets.map(slidePoints).reduce((a, b) => a.concat(b), [])\n  }\n\n  function slidePoints(offset: number): SlidePoint[] {\n    return scrollSnaps.map((snap, index) => ({\n      start: snap - slideSizes[index] + thresholds[index] + offset,\n      end: snap + viewSize - thresholds[index] + offset,\n      index,\n    }))\n  }\n\n  function check(location: number): number[] {\n    return pointsToCheck.reduce((list: number[], point) => {\n      const { index, start, end } = point\n      const inList = list.indexOf(index) !== -1\n      const inView = start < location && end > location\n      return !inList && inView ? list.concat([index]) : list\n    }, [])\n  }\n\n  const self: SlidesInView = {\n    check,\n  }\n  return self\n}\n","import { Axis } from './axis'\nimport { roundToDecimals } from './utils'\nimport { Vector1D } from './vector1d'\n\ntype Params = {\n  axis: Axis\n  container: HTMLElement\n}\n\nexport type Translate = {\n  clear: () => void\n  to: (vector: Vector1D) => void\n  toggleActive: (active: boolean) => void\n}\n\nexport function Translate(params: Params): Translate {\n  const { axis, container } = params\n  const translates = { x, y }\n  const translateAxis = translates[axis.scroll]\n  const roundToTwoDecimals = roundToDecimals(2)\n  const containerStyle = container.style\n  let disabled = false\n  let location = 0\n\n  function x(n: number): string {\n    return `translate3d(${n}%,0px,0px)`\n  }\n\n  function y(n: number): string {\n    return `translate3d(0px,${n}%,0px)`\n  }\n\n  function to(v: Vector1D): void {\n    if (disabled) return\n    const target = roundToTwoDecimals(v.get())\n\n    if (location !== target) {\n      getComputedStyle(container).transform\n      containerStyle.transform = translateAxis(target)\n      location = target\n    }\n  }\n\n  function toggleActive(active: boolean): void {\n    disabled = !active\n  }\n\n  function clear(): void {\n    containerStyle.transform = ''\n    location = 0\n  }\n\n  const self: Translate = {\n    clear,\n    to,\n    toggleActive,\n  }\n  return self\n}\n","import { Alignment } from './alignment'\nimport { Animation } from './animation'\nimport { Axis } from './axis'\nimport { Counter } from './counter'\nimport { DragHandler } from './dragHandler'\nimport { DragTracker } from './dragTracker'\nimport { EventEmitter } from './eventEmitter'\nimport { Limit } from './limit'\nimport { Options } from './options'\nimport { PxToPercent } from './pxToPercent'\nimport { ScrollBody } from './scrollBody'\nimport { ScrollBounds } from './scrollBounds'\nimport { ScrollContain } from './scrollContain'\nimport { ScrollLimit } from './scrollLimit'\nimport { ScrollLooper } from './scrollLooper'\nimport { ScrollProgress } from './scrollProgress'\nimport { ScrollSnap } from './scrollSnap'\nimport { ScrollTarget } from './scrollTarget'\nimport { ScrollTo } from './scrollTo'\nimport { SlideLooper } from './slideLooper'\nimport { SlidesInView } from './slidesInView'\nimport { Translate } from './translate'\nimport { arrayKeys, groupArray } from './utils'\nimport { Vector1D } from './vector1d'\n\nexport type Engine = {\n  axis: Axis\n  animation: Animation\n  scrollBounds: ScrollBounds\n  scrollLooper: ScrollLooper\n  scrollProgress: ScrollProgress\n  index: Counter\n  indexPrevious: Counter\n  limit: Limit\n  location: Vector1D\n  options: Options\n  pxToPercent: PxToPercent\n  scrollBody: ScrollBody\n  dragHandler: DragHandler\n  slideLooper: SlideLooper\n  slidesInView: SlidesInView\n  target: Vector1D\n  translate: Translate\n  scrollTo: ScrollTo\n  scrollTarget: ScrollTarget\n  scrollSnaps: number[]\n  snapIndexes: number[]\n}\n\nexport function Engine(\n  root: HTMLElement,\n  container: HTMLElement,\n  slides: HTMLElement[],\n  options: Options,\n  events: EventEmitter,\n): Engine {\n  // Options\n  const {\n    align,\n    axis: scrollAxis,\n    startIndex,\n    inViewThreshold,\n    loop,\n    speed,\n    dragFree,\n    slidesToScroll,\n    containScroll,\n  } = options\n\n  // Measurements\n  const axis = Axis(scrollAxis)\n  const pxToPercent = PxToPercent(axis.measure(container))\n  const viewSize = pxToPercent.totalPercent\n  const slideSizes = slides.map(axis.measure).map(pxToPercent.measure)\n  const groupedSizes = groupArray(slideSizes, slidesToScroll)\n  const snapSizes = groupedSizes.map(g => g.reduce((a, s) => a + s))\n  const snapIndexes = arrayKeys(snapSizes)\n  const contentSize = slideSizes.reduce((a, s) => a + s, 0)\n  const alignment = Alignment({ align, viewSize })\n  const scrollSnap = ScrollSnap({ snapSizes, alignment, loop })\n  const defaultSnaps = snapIndexes.map(scrollSnap.measure)\n  const contain = ScrollContain({ alignment, contentSize, viewSize })\n  const shouldContain = !loop && containScroll !== ''\n  const trimSnaps = containScroll === 'trimSnaps'\n  const containedSnaps = contain.measure(defaultSnaps, trimSnaps)\n  const scrollSnaps = shouldContain ? containedSnaps : defaultSnaps\n\n  // Index\n  const indexMax = Math.max(0, scrollSnaps.length - 1)\n  const indexSpan = Limit({ min: 0, max: indexMax })\n  const index = Counter({ limit: indexSpan, start: startIndex, loop })\n  const indexPrevious = index.clone()\n\n  // ScrollLimit\n  const scrollLimit = ScrollLimit({ loop, contentSize })\n  const limit = scrollLimit.measure(scrollSnaps)\n\n  // Draw\n  const update = (): void => {\n    engine.scrollBody.seek(target).update()\n    const settled = engine.scrollBody.settle(target)\n\n    if (!dragHandler.pointerDown()) {\n      if (!loop) engine.scrollBounds.constrain(target)\n      if (settled) {\n        engine.animation.stop()\n        events.emit('settle')\n      }\n    }\n    if (loop) {\n      const direction = engine.scrollBody.direction.get()\n      engine.scrollLooper.loop(loopVectors, direction)\n      engine.slideLooper.loop(slides)\n    }\n\n    if (!settled) events.emit('scroll')\n    engine.translate.to(engine.scrollBody.location)\n    engine.animation.proceed()\n  }\n\n  // Shared\n  const animation = Animation(update)\n  const startLocation = scrollSnaps[index.get()]\n  const location = Vector1D(startLocation)\n  const target = Vector1D(startLocation)\n  const loopVectors = [location, target]\n  const scrollBody = ScrollBody({ location, speed, mass: 1 })\n  const scrollTarget = ScrollTarget({\n    contentSize,\n    index,\n    limit,\n    loop,\n    scrollSnaps,\n    target,\n  })\n  const scrollTo = ScrollTo({\n    animation,\n    events,\n    index,\n    indexPrevious,\n    scrollTarget,\n    target,\n  })\n\n  // DragHandler\n  const dragHandler = DragHandler({\n    animation,\n    axis,\n    dragFree,\n    dragTracker: DragTracker({\n      axis,\n      pxToPercent,\n    }),\n    element: root,\n    events,\n    index,\n    limit,\n    location,\n    loop,\n    scrollBody,\n    scrollTo,\n    scrollTarget,\n    target,\n  })\n\n  // Slider\n  const engine: Engine = {\n    animation,\n    axis,\n    dragHandler,\n    pxToPercent,\n    index,\n    indexPrevious,\n    limit,\n    location,\n    options,\n    scrollBody,\n    scrollBounds: ScrollBounds({\n      animation,\n      limit,\n      location,\n      scrollBody,\n    }),\n    scrollLooper: ScrollLooper({\n      contentSize,\n      limit,\n      location,\n      pxToPercent,\n    }),\n    scrollProgress: ScrollProgress({\n      limit,\n    }),\n    scrollSnaps,\n    scrollTarget,\n    scrollTo,\n    slideLooper: SlideLooper({\n      axis,\n      contentSize,\n      location,\n      scrollSnaps,\n      slideSizes,\n      viewSize,\n    }),\n    slidesInView: SlidesInView({\n      contentSize,\n      inViewThreshold,\n      loop,\n      slideSizes,\n      viewSize,\n    }),\n    snapIndexes,\n    target,\n    translate: Translate({\n      axis,\n      container,\n    }),\n  }\n  return engine\n}\n","type Callback = (evt: EmblaEvent) => void\ntype Listeners = { [key in EmblaEvent]: Callback[] }\n\nexport type EmblaEvent =\n  | 'init'\n  | 'pointerDown'\n  | 'pointerUp'\n  | 'scroll'\n  | 'select'\n  | 'settle'\n  | 'destroy'\n  | 'reInit'\n  | 'resize'\n\nexport type EventEmitter = {\n  emit: (evt: EmblaEvent) => EventEmitter\n  on: (evt: EmblaEvent, cb: Callback) => EventEmitter\n  off: (evt: EmblaEvent, cb: Callback) => EventEmitter\n}\n\nexport function EventEmitter(): EventEmitter {\n  const listeners: Listeners = {\n    destroy: [],\n    pointerDown: [],\n    pointerUp: [],\n    init: [],\n    reInit: [],\n    resize: [],\n    scroll: [],\n    select: [],\n    settle: [],\n  }\n\n  function emit(evt: EmblaEvent): EventEmitter {\n    listeners[evt].forEach(e => e(evt))\n    return self\n  }\n\n  function on(evt: EmblaEvent, cb: Callback): EventEmitter {\n    listeners[evt] = listeners[evt].concat([cb])\n    return self\n  }\n\n  function off(evt: EmblaEvent, cb: Callback): EventEmitter {\n    listeners[evt] = listeners[evt].filter(e => e !== cb)\n    return self\n  }\n\n  const self: EventEmitter = {\n    emit,\n    off,\n    on,\n  }\n  return self\n}\n","import { AlignmentOption } from './alignment'\nimport { AxisOption } from './axis'\nimport { ScrollContainOption } from './scrollContain'\n\nexport type Options = {\n  align: AlignmentOption\n  axis: AxisOption\n  containScroll: ScrollContainOption\n  containerSelector: string\n  dragFree: boolean\n  draggable: boolean\n  draggableClass: string\n  draggingClass: string\n  inViewThreshold: number\n  loop: boolean\n  selectedClass: string\n  slidesToScroll: number\n  speed: number\n  startIndex: number\n}\n\nexport const defaultOptions: Options = {\n  align: 'center',\n  axis: 'x',\n  containScroll: '',\n  containerSelector: '*',\n  dragFree: false,\n  draggable: true,\n  draggableClass: 'is-draggable',\n  draggingClass: 'is-dragging',\n  inViewThreshold: 0,\n  loop: false,\n  selectedClass: 'is-selected',\n  slidesToScroll: 1,\n  speed: 10,\n  startIndex: 0,\n}\n\nexport type EmblaOptions = Partial<Options>\n","import { Engine } from './components/engine'\nimport { EventEmitter, EmblaEvent } from './components/eventEmitter'\nimport { EventStore } from './components/eventStore'\nimport { defaultOptions, EmblaOptions } from './components/options'\nimport {\n  addClass,\n  arrayFromCollection,\n  debounce,\n  removeClass,\n} from './components/utils'\n\nexport type EmblaCarousel = {\n  canScrollNext: () => boolean\n  canScrollPrev: () => boolean\n  clickAllowed: () => boolean\n  containerNode: () => HTMLElement\n  dangerouslyGetEngine: () => Engine\n  destroy: () => void\n  off: EventEmitter['off']\n  on: EventEmitter['on']\n  previousScrollSnap: () => number\n  reInit: (options?: EmblaOptions) => void\n  scrollNext: () => void\n  scrollPrev: () => void\n  scrollProgress: () => number\n  scrollSnapList: () => number[]\n  scrollTo: (index: number) => void\n  selectedScrollSnap: () => number\n  slideNodes: () => HTMLElement[]\n  slidesInView: (target?: boolean) => number[]\n  slidesNotInView: (target?: boolean) => number[]\n}\n\nfunction EmblaCarousel(\n  sliderRoot: HTMLElement,\n  userOptions: EmblaOptions = {},\n): EmblaCarousel {\n  const events = EventEmitter()\n  const eventStore = EventStore()\n  const debouncedResize = debounce(resize, 500)\n  const reInit = reActivate\n  const { on, off } = events\n\n  let engine: Engine\n  let activated = false\n  let options = Object.assign({}, defaultOptions)\n  let rootElementSize = 0\n  let container: HTMLElement\n  let slides: HTMLElement[]\n\n  activate(userOptions)\n\n  function storeElements(): void {\n    if (!sliderRoot) throw new Error('Missing root node ðŸ˜¢')\n\n    const selector = options.containerSelector\n    const sliderContainer = sliderRoot.querySelector(selector)\n\n    if (!sliderContainer) throw new Error('Missing container node ðŸ˜¢')\n\n    container = sliderContainer as HTMLElement\n    slides = arrayFromCollection(container.children)\n  }\n\n  function activate(partialOptions: EmblaOptions = {}): void {\n    storeElements()\n    options = Object.assign(options, partialOptions)\n    engine = Engine(sliderRoot, container, slides, options, events)\n\n    const {\n      axis,\n      scrollBody,\n      translate,\n      dragHandler,\n      slideLooper,\n    } = engine\n    const {\n      loop,\n      draggable,\n      draggableClass,\n      selectedClass,\n      draggingClass,\n    } = options\n\n    rootElementSize = axis.measure(sliderRoot)\n    eventStore.add(window, 'resize', debouncedResize)\n    translate.to(scrollBody.location)\n    slides.forEach(slideFocusEvent)\n    dragHandler.addActivationEvents()\n\n    if (loop) {\n      if (!slideLooper.canLoop()) return reActivate({ loop: false })\n      slideLooper.loop(slides)\n    }\n    if (draggable && slides.length) {\n      if (draggableClass) {\n        addClass(sliderRoot, draggableClass)\n      }\n      if (draggingClass) {\n        events.on('pointerDown', toggleDraggingClass)\n        events.on('pointerUp', toggleDraggingClass)\n      }\n    } else {\n      events.on('pointerDown', dragHandler.removeInteractionEvents)\n    }\n    if (selectedClass) {\n      toggleSelectedClass()\n      events.on('select', toggleSelectedClass)\n      events.on('pointerUp', toggleSelectedClass)\n    }\n    if (!activated) {\n      setTimeout(() => events.emit('init'), 0)\n      activated = true\n    }\n  }\n\n  function toggleDraggingClass(evt: EmblaEvent): void {\n    const { draggingClass } = options\n    if (evt === 'pointerDown') addClass(sliderRoot, draggingClass)\n    else removeClass(sliderRoot, draggingClass)\n  }\n\n  function toggleSelectedClass(): void {\n    const { selectedClass } = options\n    const inView = slidesInView(true)\n    const notInView = slidesNotInView(true)\n    notInView.forEach(i => removeClass(slides[i], selectedClass))\n    inView.forEach(i => addClass(slides[i], selectedClass))\n  }\n\n  function slideFocusEvent(slide: HTMLElement, index: number): void {\n    const focus = (): void => {\n      const groupIndex = Math.floor(index / options.slidesToScroll)\n      const selectedGroup = index ? groupIndex : index\n      sliderRoot.scrollLeft = 0\n      scrollTo(selectedGroup)\n    }\n    eventStore.add(slide, 'focus', focus, true)\n  }\n\n  function reActivate(partialOptions: EmblaOptions = {}): void {\n    const startIndex = selectedScrollSnap()\n    const newOptions = Object.assign({ startIndex }, partialOptions)\n    deActivate()\n    activate(newOptions)\n    events.emit('reInit')\n  }\n\n  function deActivate(): void {\n    engine.dragHandler.removeActivationEvents()\n    engine.dragHandler.removeInteractionEvents()\n    engine.animation.stop()\n    eventStore.removeAll()\n    engine.translate.clear()\n    engine.slideLooper.clear(slides)\n    removeClass(sliderRoot, options.draggableClass)\n    slides.forEach(s => removeClass(s, options.selectedClass))\n    events.off('select', toggleSelectedClass)\n    events.off('pointerUp', toggleSelectedClass)\n    events.off('pointerDown', toggleDraggingClass)\n    events.off('pointerUp', toggleDraggingClass)\n  }\n\n  function destroy(): void {\n    if (!activated) return\n    deActivate()\n    activated = false\n    engine = {} as Engine\n    events.emit('destroy')\n  }\n\n  function resize(): void {\n    const newRootElementSize = engine.axis.measure(sliderRoot)\n    if (rootElementSize !== newRootElementSize) reActivate()\n    events.emit('resize')\n  }\n\n  function slidesInView(target = false): number[] {\n    const location = engine[target ? 'target' : 'location'].get()\n    const type = options.loop ? 'removeOffset' : 'constrain'\n    return engine.slidesInView.check(engine.limit[type](location))\n  }\n\n  function slidesNotInView(target = false): number[] {\n    const inView = slidesInView(target)\n    return engine.snapIndexes.filter(i => inView.indexOf(i) === -1)\n  }\n\n  function scrollTo(index: number): void {\n    engine.scrollBody.useDefaultMass().useDefaultSpeed()\n    engine.scrollTo.index(index, 0)\n  }\n\n  function scrollNext(): void {\n    const next = engine.index.clone().add(1)\n    engine.scrollBody.useDefaultMass().useDefaultSpeed()\n    engine.scrollTo.index(next.get(), -1)\n  }\n\n  function scrollPrev(): void {\n    const prev = engine.index.clone().add(-1)\n    engine.scrollBody.useDefaultMass().useDefaultSpeed()\n    engine.scrollTo.index(prev.get(), 1)\n  }\n\n  function canScrollNext(): boolean {\n    const next = engine.index.clone().add(1)\n    return next.get() !== selectedScrollSnap()\n  }\n\n  function canScrollPrev(): boolean {\n    const prev = engine.index.clone().add(-1)\n    return prev.get() !== selectedScrollSnap()\n  }\n\n  function scrollSnapList(): number[] {\n    return engine.scrollSnaps.map(engine.scrollProgress.get)\n  }\n\n  function scrollProgress(): number {\n    return engine.scrollProgress.get(engine.location.get())\n  }\n\n  function selectedScrollSnap(): number {\n    return engine.index.get()\n  }\n\n  function previousScrollSnap(): number {\n    return engine.indexPrevious.get()\n  }\n\n  function clickAllowed(): boolean {\n    return engine.dragHandler.clickAllowed()\n  }\n\n  function dangerouslyGetEngine(): Engine {\n    return engine\n  }\n\n  function containerNode(): HTMLElement {\n    return container\n  }\n\n  function slideNodes(): HTMLElement[] {\n    return slides\n  }\n\n  const self: EmblaCarousel = {\n    canScrollNext,\n    canScrollPrev,\n    clickAllowed,\n    containerNode,\n    dangerouslyGetEngine,\n    destroy,\n    off,\n    on,\n    previousScrollSnap,\n    reInit,\n    scrollNext,\n    scrollPrev,\n    scrollProgress,\n    scrollSnapList,\n    scrollTo,\n    selectedScrollSnap,\n    slideNodes,\n    slidesInView,\n    slidesNotInView,\n  }\n  return self\n}\n\nexport default EmblaCarousel\n"]},"metadata":{},"sourceType":"module"}